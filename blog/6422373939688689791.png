

# Spring的Bean实例化

实例化也是在refresh()方法中完成的。上refresh()源码:

```java
	public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
			//为容器初始化做准备，重要程度：0
			// Prepare this context for refreshing.
			prepareRefresh();

			/*
			   重要程度：5
			  1、创建BeanFactory对象
			* 2、xml解析
			* 	传统标签解析：bean、import等
			* 	自定义标签解析 如：<context:component-scan base-package="com.xiangxue.jack"/>
			* 	自定义标签解析流程：
			* 		a、根据当前解析标签的头信息找到对应的namespaceUri
			* 		b、加载spring所有jar中的spring.handlers文件。并建立映射关系
			* 		c、根据namespaceUri从映射关系中找到对应的实现了NamespaceHandler接口的类
			* 		d、调用类的init方法，init方法是注册了各种自定义标签的解析类
			* 		e、根据namespaceUri找到对应的解析类，然后调用paser方法完成标签解析
			*
			* 3、把解析出来的xml标签封装成BeanDefinition对象
			* */
			// Tell the subclass to refresh the internal bean factory.
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			/*
			 * 给beanFactory设置一些属性值，可以不看
			 * */
			// Prepare the bean factory for use in this context.
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
				postProcessBeanFactory(beanFactory);

				/*
				 * BeanDefinitionRegistryPostProcessor
				 * BeanFactoryPostProcessor
				 * 完成对这两个接口的调用
				 * */
				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);

				/*
				 * 把实现了BeanPostProcessor接口的类实例化，并且加入到BeanFactory中
				 * */
				// Register bean processors that intercept bean creation.
				registerBeanPostProcessors(beanFactory);

				/*
				 * 国际化,重要程度2
				 * */
				// Initialize message source for this context.
				initMessageSource();

				//初始化事件管理类
				// Initialize event multicaster for this context.
				initApplicationEventMulticaster();

				//这个方法着重理解模板设计模式，因为在springboot中，这个方法是用来做内嵌tomcat启动的
				// Initialize other special beans in specific context subclasses.
				onRefresh();

				/*
				 * 往事件管理类中注册事件类
				 * */
				// Check for listener beans and register them.
				registerListeners();

				/*
				 * 这个方法是spring中最重要的方法，没有之一
				 * 所以这个方法一定要理解要具体看
				 * 1、bean实例化过程
				 * 2、ioc
				 * 3、注解支持
				 * 4、BeanPostProcessor的执行
				 * 5、Aop的入口
				 * */
				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);

				// Last step: publish corresponding event.
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn("Exception encountered during context initialization - " +
							"cancelling refresh attempt: " + ex);
				}

				// Destroy already created singletons to avoid dangling resources.
				destroyBeans();

				// Reset 'active' flag.
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				// Reset common introspection caches in Spring's core, since we
				// might not ever need metadata for singleton beans anymore...
				resetCommonCaches();
			}
		}
	}
```

Bean的实例话时在`finishBeanFactoryInitialization(beanFactory);`方法中完成的。

```java
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
  //省略不重要的方法
  ....
    
	// Stop using the temporary ClassLoader for type matching.
	beanFactory.setTempClassLoader(null);

	// Allow for caching all bean definition metadata, not expecting further changes.
	beanFactory.freezeConfiguration();

	//重点看这个方法，重要程度：5
	// Instantiate all remaining (non-lazy-init) singletons.
	beanFactory.preInstantiateSingletons();
}
```

看最后的方法`beanFactory.preInstantiateSingletons();`（beanFactory终于不只是注册和查找了，终于有一个与它的名字相匹配的操作了）。方法翻译是`实例化单例`，那看看是怎么实例化Bean的吧。

## DefaultListableBeanFactory#preInstantiateSingletons

```java
/*
 * 具体实例化过程
 * */
@Override
public void preInstantiateSingletons() throws BeansException {
	// Iterate over a copy to allow for init methods which in turn register new bean definitions.
	// While this may not be part of the regular factory bootstrap, it does otherwise work fine.
	// 把所有beanName都缓存到beanDefinitionNames了，这时这个BeanName所对应的是BeanDefinition
	List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);

	// Trigger initialization of all non-lazy singleton beans...
	for (String beanName : beanNames) {
		//把父BeanDefinition里面的属性拿到子BeanDefinition中
		RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
		//如果不是抽象的，单例的，非懒加载的就实例化
		if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
			//判断bean是否实现了FactoryBean接口，这里可以不看  &factoryBeanDemo
			if (isFactoryBean(beanName)) {
				Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
				if (bean instanceof FactoryBean) {
					FactoryBean<?> factory = (FactoryBean<?>) bean;
					boolean isEagerInit;
					if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
						isEagerInit = AccessController.doPrivileged(
								(PrivilegedAction<Boolean>) ((SmartFactoryBean<?>) factory)::isEagerInit,
								getAccessControlContext());
					}
					else {
						isEagerInit = (factory instanceof SmartFactoryBean &&
								((SmartFactoryBean<?>) factory).isEagerInit());
					}
					if (isEagerInit) {
						getBean(beanName);
					}
				}
			}
			else {
				//主要从这里进入，看看实例化过程
				getBean(beanName);
			}
		}
	}

	// Trigger post-initialization callback for all applicable beans...
	for (String beanName : beanNames) {
		Object singletonInstance = getSingleton(beanName);
		if (singletonInstance instanceof SmartInitializingSingleton) {
			SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
			if (System.getSecurityManager() != null) {
				AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
					smartSingleton.afterSingletonsInstantiated();
					return null;
				}, getAccessControlContext());
			}
			else {
				smartSingleton.afterSingletonsInstantiated();
			}
		}
	}
}
```

第一步就是

![image-20210313232407987](media/image-20210313232407987.png)

这个`beanDefinitionNames`就是BeanDefinition放入beanFactory的Map中后，还会把beanName放入到到beanFactory的一个list列表中，这个列表就是`beanDefinitionNames`。

然后就是遍历这个列表了。在for循环中第一行代码

`RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);`，它是把父BeanDefinition里面的属性拿到子BeanDefinition中，这是一个深度拷贝的过程，而且会返回一个RootBeanDefinition，表示该BeanDefinition需要实例化了

比如是这样定义

![image-20210313232853060](media/image-20210313232853060.png)

比如在多数据源时，有一个父的bean保存一个共有的信息，而一些独有的信息就放在自己的bean中，那这时是要这样定义就好了。

继续看代码，如果不是抽象的，是单例的，非懒加载的就实例化，那会进入到if中，

![image-20211201014139041](media/image-20211201014139041.png)

这里主要看else吧，if的话是对那些实现`FactoryBean`接口的类实例化的，这里之后再看。

## AbstractBeanFactory#getBean

getBean方法是由父类`AbstractBeanFactory`实现，跟踪代码，最后看AbstractBeanFactory#doGetBean

```java
// AbstractBeanFactory
protected <T> T doGetBean(
		String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly)
		throws BeansException {
	// 这里会解析出真实的beanName，对于实现了FactoryBean的接口，在进入这个方法时会在beanName前加上&这个符号
	String beanName = transformedBeanName(name);
	Object bean;

	//从缓存中拿实例
	// Eagerly check singleton cache for manually registered singletons.
	Object sharedInstance = getSingleton(beanName);
	//如果缓存里面能拿到实例
	if (sharedInstance != null && args == null) {
		//该方法是FactoryBean接口的调用入口
		bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
	}

	else {
		//如果singletonObjects缓存里面没有，则走下来
		// Fail if we're already creating this bean instance:
		// We're assumably within a circular reference.
		//如果是scope 是Prototype的，校验是否有出现循环依赖，如果有则直接报错
		if (isPrototypeCurrentlyInCreation(beanName)) {
			throw new BeanCurrentlyInCreationException(beanName);
		}

		// Check if bean definition exists in this factory.
		BeanFactory parentBeanFactory = getParentBeanFactory();
		if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
			// Not found -> check parent.
			String nameToLookup = originalBeanName(name);
			if (parentBeanFactory instanceof AbstractBeanFactory) {
				return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
						nameToLookup, requiredType, args, typeCheckOnly);
			}
			else if (args != null) {
				// Delegation to parent with explicit args.
				return (T) parentBeanFactory.getBean(nameToLookup, args);
			}
			else if (requiredType != null) {
				// No args -> delegate to standard getBean method.
				return parentBeanFactory.getBean(nameToLookup, requiredType);
			}
			else {
				return (T) parentBeanFactory.getBean(nameToLookup);
			}
		}

		if (!typeCheckOnly) {
			markBeanAsCreated(beanName);
		}

		try {
			//父子BeanDefinition合并
			RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
			checkMergedBeanDefinition(mbd, beanName, args);

			//获取依赖对象属性，依赖对象要先实例化
			// Guarantee initialization of beans that the current bean depends on.
			String[] dependsOn = mbd.getDependsOn();
			if (dependsOn != null) {
				for (String dep : dependsOn) {
					if (isDependent(beanName, dep)) {
						throw new BeanCreationException(mbd.getResourceDescription(), beanName,
								"Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
					}
					registerDependentBean(dep, beanName);
					try {
						//实例化
						getBean(dep);
					}
					catch (NoSuchBeanDefinitionException ex) {
						throw new BeanCreationException(mbd.getResourceDescription(), beanName,
								"'" + beanName + "' depends on missing bean '" + dep + "'", ex);
					}
				}
			}

			//着重看，大部分是单例的情况
			// Create bean instance.
			if (mbd.isSingleton()) {
				sharedInstance = getSingleton(beanName, () -> {
					try {
						return createBean(beanName, mbd, args);
					}
					catch (BeansException ex) {
						// Explicitly remove instance from singleton cache: It might have been put there
						// eagerly by the creation process, to allow for circular reference resolution.
						// Also remove any beans that received a temporary reference to the bean.
						destroySingleton(beanName);
						throw ex;
					}
				});
				//该方法是FactoryBean接口的调用入口
				bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
			}

			else if (mbd.isPrototype()) {
				// It's a prototype -> create a new instance.
				Object prototypeInstance = null;
				try {
					beforePrototypeCreation(beanName);
					prototypeInstance = createBean(beanName, mbd, args);
				}
				finally {
					afterPrototypeCreation(beanName);
				}
				//该方法是FactoryBean接口的调用入口
				bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
			}

			else {
				String scopeName = mbd.getScope();
				if (!StringUtils.hasLength(scopeName)) {
					throw new IllegalStateException("No scope name defined for bean ´" + beanName + "'");
				}
				Scope scope = this.scopes.get(scopeName);
				if (scope == null) {
					throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
				}
				try {
					Object scopedInstance = scope.get(beanName, () -> {
						beforePrototypeCreation(beanName);
						try {
							return createBean(beanName, mbd, args);
						}
						finally {
							afterPrototypeCreation(beanName);
						}
					});
					bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
				}
				catch (IllegalStateException ex) {
					throw new BeanCreationException(beanName,
							"Scope '" + scopeName + "' is not active for the current thread; consider " +
							"defining a scoped proxy for this bean if you intend to refer to it from a singleton",
							ex);
				}
			}
		}
		catch (BeansException ex) {
			cleanupAfterBeanCreationFailure(beanName);
			throw ex;
		}
	}

	// Check if required type matches the type of the actual bean instance.
	if (requiredType != null && !requiredType.isInstance(bean)) {
		try {
			T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
			if (convertedBean == null) {
				throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
			}
			return convertedBean;
		}
		catch (TypeMismatchException ex) {
			if (logger.isTraceEnabled()) {
				logger.trace("Failed to convert bean '" + name + "' to required type '" +
						ClassUtils.getQualifiedName(requiredType) + "'", ex);
			}
			throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
		}
	}
	return (T) bean;
}
```

先看

```java
String beanName = transformedBeanName(name);
```

这里会解析出真实的beanName，对于实现了FactoryBean的接口，在进入这个方法时会在beanName前加上&这个符号。经过这个方法后，会去掉&符号，所以进入了方法后对于FactoryBean的接口的BeanDefinition，会有两个名字，一个是

```
name=&beanName
beanName=beanName
```

接着看

```java
Object sharedInstance = getSingleton(beanName);
```

`getSingleton`方法是从`DefaultSingletonBeanRegistry`继承过来的，该方法会根据beanName从缓存中拿实例，进去看看`getSingleton`：

```java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
	//根据beanName从缓存中拿实例
	//先从一级缓存拿
	Object singletonObject = this.singletonObjects.get(beanName);
	//如果bean还正在创建，还没创建完成，其实就是堆内存有了，属性还没有DI依赖注入
	if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
		synchronized (this.singletonObjects) {
			//从二级缓存中拿
			singletonObject = this.earlySingletonObjects.get(beanName);
			//如果还拿不到，并且允许bean提前暴露
			if (singletonObject == null && allowEarlyReference) {
				//从三级缓存中拿到对象工厂
				ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
				if (singletonFactory != null) {
					//从工厂中拿到对象
					singletonObject = singletonFactory.getObject();
					//升级到二级缓存
					this.earlySingletonObjects.put(beanName, singletonObject);
					//删除三级缓存
					this.singletonFactories.remove(beanName);
				}
			}
		}
	}
	return singletonObject;
}
```

就是从缓存一级一级找。回到开始的，看没拿到的情况，也就是else代码块的代码。

### 通过父BeanFactory获取bean

![image-20211211022135215](media/image-20211211022135215.png)

可以看到，这段代码先通过`getParentBeanFactory()`父BeanFactory，如果存在，并且当前的BeanFactory不存在对应beanName的BeanDefinition，那么就会尝试使用父BeanFactory获取Bean。

### DefaultSingletonBeanRegistry#getSingleton

先看下面的代码段：

![image-20210313235308007](media/image-20210313235308007.png)

`RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);`上面讲过了，看下面处理dependsOn的

比如这样定义一个bean

![image-20210313235418803](media/image-20210313235418803.png)

那这个student的实例化是要依赖james13的，也就是说james13要先实例话，student才能实例话。回到源码，逻辑就是上面的逻辑，也就是先去getBean('james13')，然后在往下实例化student

接着看代码块：

![image-20210313235741114](media/image-20210313235741114.png)

从if就知道，这代码块就是创建单例的Bean，也就是默认的情况。

`getSingleton(String beanName, ObjectFactory<?> singletonFactory)`方法又是从`DefaultSingletonBeanRegistry`继承过来的

看`DefaultSingletonBeanRegistry#getSingleton`方法。

```java
public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {
	Assert.notNull(beanName, "Bean name must not be null");
	synchronized (this.singletonObjects) {
		//如果缓存中有，则直接返回
		Object singletonObject = this.singletonObjects.get(beanName);
		if (singletonObject == null) {
      //打印日志
			......
			//把beanName添加到singletonsCurrentlyInCreation Set容器中，在这个集合里面的bean都是正在实例化的bean
			beforeSingletonCreation(beanName);
			boolean newSingleton = false;
			boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
			if (recordSuppressedExceptions) {
				this.suppressedExceptions = new LinkedHashSet<>();
			}
			try {
				//如果这里有返回值，就代表这个bean已经结束创建了，已经完全创建成功
				singletonObject = singletonFactory.getObject();
				newSingleton = true;
			}
			catch (IllegalStateException ex) {
				// Has the singleton object implicitly appeared in the meantime ->
				// if yes, proceed with it since the exception indicates that state.
				singletonObject = this.singletonObjects.get(beanName);
				if (singletonObject == null) {
					throw ex;
				}
			}
			catch (BeanCreationException ex) {
				if (recordSuppressedExceptions) {
					for (Exception suppressedException : this.suppressedExceptions) {
						ex.addRelatedCause(suppressedException);
					}
				}
				throw ex;
			}
			finally {
				if (recordSuppressedExceptions) {
					this.suppressedExceptions = null;
				}
				//bean创建完成后singletonsCurrentlyInCreation要删除该bean
				afterSingletonCreation(beanName);
			}
			if (newSingleton) {
				//创建对象成功时，把对象缓存到singletonObjects缓存中,bean创建完成时放入一级缓存
				addSingleton(beanName, singletonObject);
			}
		}
		return singletonObject;
	}
}
```

> 注这里的
>
> ```java
> ObjectFactory<?> singletonFactory = {
>    try {
>       return createBean(beanName, mbd, args);
>    }
>    catch (BeansException ex) {
>       .....
>       throw ex;
>    }
> }
> ```

先从一级缓`singletonObjects集合`中存拿对象，看没拿到的情况就会进行创建逻辑

`beforeSingletonCreation(beanName);`，该方法的作用就是把beanName添加到singletonsCurrentlyInCreation容器中，在这个集合里面的bean都是正在实例化的bean。

![image-20210314000930688](media/image-20210314000930688.png)

![image-20210314000953492](media/image-20210314000953492.png)

接着到

![image-20210314001122568](media/image-20210314001122568.png)

这个singletonFactory是在进入方法时传的一个匿名对象

![image-20210314001302269](media/image-20210314001302269.png)

也就是说，调用getObject时，实际上时调用了createBean(beanName, mbd, args)方法。注意

1. getObject调用完成后，就意味着bean已经完成了创建

2. 上面的`createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)`方法是在`AbstractBeanFactory`中定义的，它是一个抽象方法，这个方法的实现由`AbstractAutowireCapableBeanFactory`实现。


看`AbstractAutowireCapableBeanFactory#createBean`

```java
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
		throws BeanCreationException {

	RootBeanDefinition mbdToUse = mbd;

	// Make sure bean class is actually resolved at this point, and
	// clone the bean definition in case of a dynamically resolved Class
	// which cannot be stored in the shared merged bean definition.
	Class<?> resolvedClass = resolveBeanClass(mbd, beanName);
	if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
		mbdToUse = new RootBeanDefinition(mbd);
		mbdToUse.setBeanClass(resolvedClass);
	}

	// Prepare method overrides.
	try {
		mbdToUse.prepareMethodOverrides();
	}
  //去掉了catch语句块
  .......

	try {
		/*
		 * TargetSource接口的运用，可以在用改一个类实现该接口，然后在里面定义实例化对象的方式，然后返回
		 * 也就是说不需要spring帮助我们实例化对象
		 *
		 *
		 * 这里可以直接返回实例本身
		 *
		 * 这个代码不用看，实际开发过程中用不到，我会做为一个甜点分享
		 * */
		// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
		Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
		if (bean != null) {
			return bean;
		}
	}
  //去掉了catch语句块
  .......

	try {
		//主要看这个方法，重要程度 5
		Object beanInstance = doCreateBean(beanName, mbdToUse, args);
		if (logger.isTraceEnabled()) {
			logger.trace("Finished creating instance of bean '" + beanName + "'");
		}
		return beanInstance;
	}
  //去掉了catch语句块
  .......
}
```

重点看这段代码块：

![image-20210314002619078](media/image-20210314002619078.png)

### AbstractAutowireCapableBeanFactory#doCreateBean

```java
protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
		throws BeanCreationException {

	// Instantiate the bean.
	BeanWrapper instanceWrapper = null;
	if (mbd.isSingleton()) {
		instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
	}
	if (instanceWrapper == null) {
		//创建实例,,重点看，重要程度：5
		instanceWrapper = createBeanInstance(beanName, mbd, args);
	}
	Object bean = instanceWrapper.getWrappedInstance();
	Class<?> beanType = instanceWrapper.getWrappedClass();
	if (beanType != NullBean.class) {
		mbd.resolvedTargetType = beanType;
	}

	// Allow post-processors to modify the merged bean definition.
	synchronized (mbd.postProcessingLock) {
		if (!mbd.postProcessed) {
			try {
				//CommonAnnotationBeanPostProcessor  支持了@PostConstruct，@PreDestroy,@Resource注解
				//AutowiredAnnotationBeanPostProcessor 支持 @Autowired,@Value注解
				//BeanPostProcessor接口的典型运用，这里要理解这个接口
				//对类中注解的装配过程
				//重要程度5，必须看
				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
			}
			catch (Throwable ex) {
				//打印日志
        .......
			}
			mbd.postProcessed = true;
		}
	}

	// Eagerly cache singletons to be able to resolve circular references
	// even when triggered by lifecycle interfaces like BeanFactoryAware.
	//是否	单例bean提前暴露
	boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
			isSingletonCurrentlyInCreation(beanName));
	if (earlySingletonExposure) {
		if (logger.isTraceEnabled()) {
			//打印日志
      ......
		}
		//这里着重理解，对理解循环依赖帮助非常大，重要程度 5   添加三级缓存
		addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
	}

	// Initialize the bean instance.
	Object exposedObject = bean;
	try {
		//ioc di，依赖注入的核心方法，该方法必须看，重要程度：5
		populateBean(beanName, mbd, instanceWrapper);
		//bean 实例化+ioc依赖注入完以后的调用，非常重要，重要程度：5
		exposedObject = initializeBean(beanName, exposedObject, mbd);
	}
	catch (Throwable ex) {
    //抛出BeanCreationException错误
    .......
	}

	if (earlySingletonExposure) {
		Object earlySingletonReference = getSingleton(beanName, false);
		if (earlySingletonReference != null) {
			if (exposedObject == bean) {
				exposedObject = earlySingletonReference;
			}
			else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
				String[] dependentBeans = getDependentBeans(beanName);
				Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);
				for (String dependentBean : dependentBeans) {
					if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
						actualDependentBeans.add(dependentBean);
					}
				}
				if (!actualDependentBeans.isEmpty()) {
          //抛出BeanCurrentlyInCreationException错误
        	.......
				}
			}
		}
	}

	// Register bean as disposable.
	try {
		//注册bean销毁时的类DisposableBeanAdapter
		registerDisposableBeanIfNecessary(beanName, bean, mbd);
	}
	catch (BeanDefinitionValidationException ex) {
    //抛出BeanCreationException错误
    .......
	}

	return exposedObject;
}
```

这是一个*非常非常重要*的方法，这里包含一个Spring bean的整个初始化流程，重要的方法

1. `BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)`
2. `void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class<?> beanType, String beanName)`
3. `void addSingletonFactory(String beanName, ObjectFactory<?> singletonFactory)`
4. `void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)`
5. `Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd)`
6. `void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd)`

下面我们一个个方法

#### `createBeanInstance`----Bean 的实例化过程（控制反转IOC）

先看这段代码，也就是开头的代码

![image-20210314003020512](media/image-20210314003020512.png)

真正是实例就是在这段代码里完成的。

先总结这个方法的作用：

![image-20210314003604150](media/image-20210314003604150.png)

源码:

```java
protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
	// Make sure bean class is actually resolved at this point.
	Class<?> beanClass = resolveBeanClass(mbd, beanName);

	if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {
    //抛出BeanCreationException错误
    .......
	}

	Supplier<?> instanceSupplier = mbd.getInstanceSupplier();
	if (instanceSupplier != null) {
		return obtainFromSupplier(instanceSupplier, beanName);
	}

	//如果有FactoryMethodName属性 @Bean
	if (mbd.getFactoryMethodName() != null) {
		return instantiateUsingFactoryMethod(beanName, mbd, args);
	}

	// Shortcut when re-creating the same bean...
	boolean resolved = false;
	boolean autowireNecessary = false;
	if (args == null) {
		synchronized (mbd.constructorArgumentLock) {
			if (mbd.resolvedConstructorOrFactoryMethod != null) {
				resolved = true;
				autowireNecessary = mbd.constructorArgumentsResolved;
			}
		}
	}
	if (resolved) {
		if (autowireNecessary) {
			return autowireConstructor(beanName, mbd, null, null);
		}
		else {
			return instantiateBean(beanName, mbd);
		}
	}

	// Candidate constructors for autowiring?
	//寻找当前正在实例化的bean中有@Autowired注解的构造函数
	Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
	if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
			mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
		//如果ctors不为空，就说明构造函数上有@Autowired注解
		return autowireConstructor(beanName, mbd, ctors, args);
	}

	// Preferred constructors for default construction?
	ctors = mbd.getPreferredConstructors();
	if (ctors != null) {
		return autowireConstructor(beanName, mbd, ctors, null);
	}

	//无参构造函数的实例化,大部分的实例是采用的无参构造函数的方式实例化
	// No special handling: simply use no-arg constructor.
	return instantiateBean(beanName, mbd);
}
```



#####  \<bean>标签里面。配置了factory-method属性的情况

先执行这里：

![image-20210314004115677](media/image-20210314004115677.png)

这段代码的if只有在下面的情况才会进去。

-  <bean>标签里面。配置了factory-method属性
  ![image-20210314004547189](media/image-20210314004547189.png)
- 或者方法上面加上@Bean注解

看下`AbstractAutowireCapableBeanFactory#instantiateUsingFactoryMethod`方法。

![image-20210314005401023](media/image-20210314005401023.png)

`ConstructorResolver#instantiateUsingFactoryMethod`方法:(不弄完整的代码了，只看核心的)

这样配置的情况

![image-20210314004547189](media/image-20210314004547189.png)

![image-20210314005636142](media/image-20210314005636142.png)

创建好了`BeanWrapperImpl`包装类后，调用`beanFactory.getBean(factoryBeanName)`，也就是说先去获取factoryBean(没有就执行创建流程)，获取到了方法所对应的对象，并且isStatic = false。接着走

![image-20210314010407818](media/image-20210314010407818.png)

从所有factoryBean对应的类中拿到全部方法，并找到匹配的方法，而且由于isStatic = false，所以不能拿到静态的方法。接着走

![image-20210314010731964](media/image-20210314010731964.png)

instantiate方法不用看了，就是用反射调用这种形式的api：`Method.invoke(Object object, Object... args)`

方法调用完后就按定义实力化bean了，并返回了。接着会把放回的bean放入到之前创建的`BeanWrapperImpl`的对象中。后面还有多个方法，不过我不想看了，最后还是只有一个方法会被调用。

不过除了上面的情况还，还可以这样配置

![image-20210314011825277](media/image-20210314011825277.png)

不过这就要求方法factoryMethod是静态的方法了。这种情况就会走到一开始的else情况，后面都一样

![image-20210314011933372](media/image-20210314011933372.png)

factory-method的处理结束了。

##### 方法上面加上@Bean注解

@Bean的方式是使用了factory-method的方式来实现的，它使用的是非静态方法的那种方式。

比如有这样的配置类

![image-20210314012415407](media/image-20210314012415407.png)

其实就是相当于

![image-20210314012618777](media/image-20210314012618777.png)

##### 实例化带有@Autowired注解的构造函数

回到`AbstractAutowireCapableBeanFactory#createBeanInstance`，代码一直走

![image-20210314013048372](media/image-20210314013048372.png)

这个方法的作用就是通过构造方法注入值，比如有这样一个类

![image-20210314013331498](media/image-20210314013331498.png)

那Spring会把sc对象，和cq对象传入AutowiredConsturctorBean对象中。看回源码。

代码`determineConstructorsFromBeanPostProcessors`

![image-20210314013940526](media/image-20210314013940526.png)

getBeanPostProcessors()回获取`BeanPostProcessor`的实例，这些实例是在refresh()方法中，执行了`BeanDefinitionRegistryPostProcessor`这种后置处理器的方法后，调用了`registryBeanPostProcessor`方法去实例化对应的`BeanPostProcessor`的实例，并且注册到beanFacotry的beanPostProcessors中

![image-20210314014426024](media/image-20210314014426024.png)

回到for代码。这里会有多个`BeanPostProcessor`会被调用到，不过我们关注的是这个

![image-20210314014728053](media/image-20210314014728053.png)

`AutowireAnnotationBeanPostProcessor`，进去看`determineCandidateConstructors`方法

![image-20210314015210347](media/image-20210314015210347.png)

代码接着走

![image-20210314015307522](media/image-20210314015307522.png)

![image-20210314015354758](media/image-20210314015354758.png)

遍历构造函数，获取到构造函数上的@Autowired注解信息，接着

![image-20210314015628822](media/image-20210314015628822.png)

获取@Autowired的required的值，默认为true。这个值的作用就是为true时，如果注入的对象不存在就报错，为false的时候，如果如果注入的对象不存在，不报错(对应引用，还是使用默认值null)。

最后![image-20210314020016027](media/image-20210314020016027.png)

放入`candidateConstructorsCache`后就返回了

![image-20210314020031833](media/image-20210314020031833.png)

回到`AbstractAutowireCapableBeanFactory#createBeanInstance`，假如返回的不为null，那看方法

`autowireConstructor(beanName, mbd, ctors, args)`:

![image-20210314020226016](media/image-20210314020226016.png)

看`ConstructorResolver#autowireConstructor`方法

该方法其实是更具构造方法创建对象的过程，不过有个问题，就是构造方法的参数怎么获取。其实我猜测和factoryMethod一样。跟踪源码一直到

![image-20210314022410320](media/image-20210314022410320.png)

这方法的流程太长了，代码不看了，最后都会调用`beanFactory.getBean`方法。

有一种情况，多个构造函数上有@Autowire，默认情况下会报错，因为源码中

回到`AutowireAnnotationBeanPostProcessor#determineConstructorsFromBeanPostProcessors`方法，在

![image-20210314024535945](media/image-20210314024535945.png)

只要required=false就不报错了。如果有多个构造函数，会根据构造函数参数个数排序，而且只会用一个构造函数。

##### 实例化没有@Autowired的有参构造函数

`AutowireAnnotationBeanPostProcessor#determineConstructorsFromBeanPostProcessors`方法在没有@Autowired是会根据情况返回构造函数的。之后都是调用autowireConstructor方法的。不过对于这种情况要注意一点，如果想这种情况走通，一定只能有一个带参数的构造函数。

##### 实例化无参构造函数

上面的情况都不符合的才会走到这里

![image-20210314031529751](media/image-20210314031529751.png)

##### 总结

其实就是如果有依赖别的bean的，先去创建别的bean。而且这里只是分配的内存空间，对象的属性还没有处理，也就是还没到依赖注入这阶段。

#### applyMergedBeanDefinitionPostProcessors---对类中注解的收集和装配过程

createBeanInstance方法只是实例化对象(控制反转)，并没有处理依赖注入的问题。而applyMergedBeanDefinitionPostProcessors会对类中注解执行收集过程

![image-20210314033015562](media/image-20210314033015562.png)

![image-20210314033030615](media/image-20210314033030615.png)

又是getBeanPostProcessors()，在这里Spring会帮我们放入一些`BeanPostProcessor`，这里还有个要求，就是要实现的是`MergedBeanDefinitionPostProcessor`这个接口，看会[01-Spring中BeanDefinition的创建和注册](./01-Spring中BeanDefinition的创建和注册)最后的3张类图，我们关注的3个`BeanPostProcessor`只有两个是实现这个接口的。这两个就是

- `CommonAnnotationBeanPostProcessor`
- `AutowiredAnnotationBeanPostProcessor`

下面看这个两个类的`postProcessMergedBeanDefinition`方法

##### `AutowiredAnnotationBeanPostProcessor#postProcessMergedBeanDefinition`

跟踪代码

```java
public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {
	InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, null);
	metadata.checkConfigMembers(beanDefinition);
}

private InjectionMetadata findAutowiringMetadata(String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {
	// Fall back to class name as cache key, for backwards compatibility with custom callers.
	String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());
	// Quick check on the concurrent map first, with minimal locking.
	InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);
	if (InjectionMetadata.needsRefresh(metadata, clazz)) {
		synchronized (this.injectionMetadataCache) {
			metadata = this.injectionMetadataCache.get(cacheKey);
			if (InjectionMetadata.needsRefresh(metadata, clazz)) {
				if (metadata != null) {
					metadata.clear(pvs);
				}
				//主要看这个方法
				metadata = buildAutowiringMetadata(clazz);
				this.injectionMetadataCache.put(cacheKey, metadata);
			}
		}
	}
	return metadata;
}
 --->
AutowiredAnnotationBeanPostProcessor#buildAutowiringMetadata
```

`findAutowiringMetadata`的作用就是缓存和从缓存中拿`InjectionMetadata`对象，其核心就是调用了`buildAutowiringMetadata`。

看`AutowiredAnnotationBeanPostProcessor#buildAutowiringMetadata`

```java
private InjectionMetadata buildAutowiringMetadata(final Class<?> clazz) {
	if (!AnnotationUtils.isCandidateClass(clazz, this.autowiredAnnotationTypes)) {
		return InjectionMetadata.EMPTY;
	}

	List<InjectionMetadata.InjectedElement> elements = new ArrayList<>();
	Class<?> targetClass = clazz;

	do {
		final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();

		//寻找field上面的@Autowired注解并封装成对象
		ReflectionUtils.doWithLocalFields(targetClass, field -> {
			MergedAnnotation<?> ann = findAutowiredAnnotation(field);
			if (ann != null) {
				if (Modifier.isStatic(field.getModifiers())) {
        	//去掉一些打印日志的
        	.....
					return;
				}
				boolean required = determineRequiredStatus(ann);
				currElements.add(new AutowiredFieldElement(field, required));
			}
		});

		//寻找Method上面的@Autowired注解并封装成对象
		ReflectionUtils.doWithLocalMethods(targetClass, method -> {
			Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);
			if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {
				return;
			}
			MergedAnnotation<?> ann = findAutowiredAnnotation(bridgedMethod);
			if (ann != null && method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) {
        //去掉一些打印日志的
        .....
				boolean required = determineRequiredStatus(ann);
				PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);
				currElements.add(new AutowiredMethodElement(method, required, pd));
			}
		});

		elements.addAll(0, currElements);
		targetClass = targetClass.getSuperclass();
	}
	while (targetClass != null && targetClass != Object.class);

	return InjectionMetadata.forElements(elements, clazz);
}
```

![image-20211201034115280](media/image-20211201034115280.png)

这里就是收集这个类上，有某些注解的属性，而判断的的方法就是在`findAutowiredAnnotation`

```java
public AutowiredAnnotationBeanPostProcessor() {
	this.autowiredAnnotationTypes.add(Autowired.class);
	this.autowiredAnnotationTypes.add(Value.class);
	try {
		this.autowiredAnnotationTypes.add((Class<? extends Annotation>)
				ClassUtils.forName("javax.inject.Inject", AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));
		logger.trace("JSR-330 'javax.inject.Inject' annotation found and supported for autowiring");
	}
	catch (ClassNotFoundException ex) {
		// JSR-330 API not available - simply skip.
	}
}

@Nullable
private MergedAnnotation<?> findAutowiredAnnotation(AccessibleObject ao) {
	MergedAnnotations annotations = MergedAnnotations.from(ao);
	for (Class<? extends Annotation> type : this.autowiredAnnotationTypes) {
		MergedAnnotation<?> annotation = annotations.get(type);
		if (annotation.isPresent()) {
			return annotation;
		}
	}
	return null;
}
```

可以看到，这里有3个注解。其中就有`@Autowired`和`@Value`

而且，会把有这些注解的Field（属性）和 required（是否必须，默认为true）值包装成一个`AutowiredFieldElement`对象。

后面一个doWithLocalMethods是找方法上有@Autowire的，把必要信息封装成`AutowiredMethodElement`：

![image-20210504034041835](media/image-20210504034041835.png)

也就是说，只要有@Value和@Autowire的注解的方法或属性，就会创建一个`AutowiredMethodElement`对象，然后放到一个集合中。

最后，将上边创建的`AutowiredMethodElement`对象集合封装成`InjectionMetadata`并返回：

![image-20211201035152364](media/image-20211201035152364.png)

![image-20210504034257011](media/image-20210504034257011.png)

该方法返回后，会把`InjectionMetadata`对象放到一个injectionMetadataCache缓存中。

![image-20210314035243562](media/image-20210314035243562.png)

![image-20210314035312540](media/image-20210314035312540.png)

##### `CommonAnnotationBeanPostProcessor#postProcessMergedBeanDefinition`

CommonAnnotationBeanPostProcessor的过程和上面基本一样，就是关注的注解不同。

![image-20210314040313420](media/image-20210314040313420.png)

![image-20210314040627917](media/image-20210314040627917.png)

不过这个类实际上只是处理了@Resource注解而已，真实的处理`@PostConstruct`和`@PreDestroy`注解的是在其父类`InitDestroyAnnotationBeanPostProcessor`上处理的。

```java
public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {
	super.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);
	InjectionMetadata metadata = findResourceMetadata(beanName, beanType, null);
	metadata.checkConfigMembers(beanDefinition);
}
```

不过处理的逻辑都是一样，`@PostConstruct`和`@PreDestroy`只能在方法上。而`@Resource`能在属性和方法上。不过，对应注解封装成的对象不同而已，对于`@PostConstruct`和`@PreDestroy`的方法封装成`LifecycleElement`，对于`@Resource`，会封装成`ResourceElement`。

> CommonAnnotationBeanPostProcessor其实还有其他注解的
>
> - `WebServiceRef`
> - `EJB`
>
> 不过这些用都没用过，就不管了

##### 总结

这个方法就是去收集注解的

```
CommonAnnotationBeanPostProcessor  收集了@PostConstruct，@PreDestroy,@Resource注解
AutowiredAnnotationBeanPostProcessor 收集了 @Autowired,@Value注解
```



#### addSingletonFactory---对理解循环依赖帮助非常大

> 这里着重理解，对理解循环依赖帮助非常大，重要程度 5   添加三级缓存

这个方法在`doCreateBean`方法中的代码段是:

![image-20210314174541428](media/image-20210314174541428.png)

执行的前提是这个Bean的作用域是`Singleton`、beanFactory的allowCircularReferences为true（也就是开启循环依赖，默认开启）最后要`isSingletonCurrentlyInCreation(beanName)`。

这个`isSingletonCurrentlyInCreation(beanName)`是什么意识呢？[`DefaultSingletonBeanRegistry#getSingleton`](#DefaultSingletonBeanRegistry#getSingleton)代码的（也就是`doCreateBean`的外层方法），调用了下面代码

```java
beforeSingletonCreation(beanName);
```

把beanName添加到singletonsCurrentlyInCreation Set容器中，在这个集合里面的bean都是正在实例化的bean

而`isSingletonCurrentlyInCreation(beanName)`就是判断这个beanName是否在singletonsCurrentlyInCreation Set容器的，也就是判断是否在创建中。正常情况会这个方法会返回true

条件都满足了就调用代码：

```java
addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
```

这里先记下这个`ObjectFactory<?> singletonFactory = () -> getEarlyBeanReference(beanName, mbd, bean)`对象记下，看`addSingletonFactory`源码:

```java
protected void addSingletonFactory(String beanName, ObjectFactory<?> singletonFactory) {
	Assert.notNull(singletonFactory, "Singleton factory must not be null");
	synchronized (this.singletonObjects) {
		//如果一级缓存不存在
		if (!this.singletonObjects.containsKey(beanName)) {
			//设置三级缓存
			this.singletonFactories.put(beanName, singletonFactory);
			//删除二级缓存
			this.earlySingletonObjects.remove(beanName);
			this.registeredSingletons.add(beanName);
		}
	}
}
```

代码很简单，重要的一个作用就是设置三级缓存。

首先`singletonObjects`如果存在，就表示这个对象已经创建完成了，没有的话就会去设置三级缓存，并删除二级缓存。

看下三级缓存的定义![image-20210314180005128](media/image-20210314180005128.png)

也就是说设置三级缓存的意义就是建立beanName和这个对象——`() -> getEarlyBeanReference(beanName, mbd, bean)`的映射关系。

这个方法的作用就是这个，没别的了。

#### populateBean---依赖注入（DI）的核心方法

依赖注入的核心方法

```java
protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
  //去掉不重要的方法
  ....

	//这里很有意思，写接口可以让所有类都不能依赖注入
	if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
		for (BeanPostProcessor bp : getBeanPostProcessors()) {
			if (bp instanceof InstantiationAwareBeanPostProcessor) {
				InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
				if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
					return;
				}
			}
		}
	}

	PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);

	int resolvedAutowireMode = mbd.getResolvedAutowireMode();
	if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
		MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
		// Add property values based on autowire by name if applicable.
		if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {
			autowireByName(beanName, mbd, bw, newPvs);
		}
		// Add property values based on autowire by type if applicable.
		if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
			autowireByType(beanName, mbd, bw, newPvs);
		}
		pvs = newPvs;
	}

	boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
	boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);

	PropertyDescriptor[] filteredPds = null;
	//重点看这个if代码块，重要程度 5
	if (hasInstAwareBpps) {
		if (pvs == null) {
			pvs = mbd.getPropertyValues();
		}
		for (BeanPostProcessor bp : getBeanPostProcessors()) {
			if (bp instanceof InstantiationAwareBeanPostProcessor) {
				InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
				//依赖注入过程，@Autowired的支持
				PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
				if (pvsToUse == null) {
					if (filteredPds == null) {
						filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
					}

					//老版本用这个完成依赖注入过程，@Autowired的支持
					pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
					if (pvsToUse == null) {
						return;
					}
				}
				pvs = pvsToUse;
			}
		}
	}
	if (needsDepCheck) {
		if (filteredPds == null) {
			filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
		}
		checkDependencies(beanName, mbd, filteredPds, pvs);
	}

	//这个方法很鸡肋了，建议不看，是老版本用<property name="username" value="Jack"/>
	//标签做依赖注入的代码实现，复杂且无用
	if (pvs != null) {
		applyPropertyValues(beanName, mbd, bw, pvs);
	}
}
```

这里我们按功能来分析代码，先看下面代码块。

![image-20210504035606488](media/image-20210504035606488.png)

这里又是BeanPostProcessor接口的应用。

这里我们可以自己写个类实现InstantiationAwareBeanPostProcessor接口，`postProcessAfterInstantiation`方法返回一个false，就可以不走依赖注入了。比如弄个有条件的依赖注入，类似这样

![image-20210314043239159](media/image-20210314043239159.png)

感觉这个扩展没什么用，只是用来坑人用的。接着后面的代码

![image-20210314043904779](media/image-20210314043904779.png)

又是BeanPostProcessor接口的应用，虽然实现`InstantiationAwareBeanPostProcessor`的类比较多，不过我们还是只关注两个

![image-20211201045510424](media/image-20211201045510424.png)

##### `AutowiredAnnotationBeanPostProcessor#postProcessProperties`

![image-20210314044321531](media/image-20210314044321531.png)

这个方法之前已经说过了。

之前在`applyMergedBeanDefinitionPostProcessors`已经收集好了注解了，而且，做了一个beanName和`InjectionMetadata`的映射。所以这里只需要用beanName就可以获取到`InjectionMetadata`对象了，这个对象就包含了beanName中，对应的注解信息（@Autowite，@Value等）。之后执行`metadata.inject`，这个方法就是依赖注入的核心。

![image-20210314045622236](media/image-20210314045622236.png)

先看`AutowiredFieldElement#inject`

![image-20210314045731539](media/image-20210314045731539.png)

重点是这个方法，这个方法会触发`beanFactory.getBean`方法的，也就是说如果A->B->C。

A在这个方法中会触发beanFactory.getBean(B)。接着B又在这个方法中会触发beanFactory.getBean(C)

最后调用

![image-20210314050130390](media/image-20210314050130390.png)

第一个就是调用`field.setAccessible(true);`，然后通过反射向字段设置值，也就是说依赖的属性现在经过这样的处理后就完成了值的设置了。

DI已经完成了，原理是真的简单，重点只是在收集注解上而已。

方法的依赖注入都一样的。

![image-20210314050610943](media/image-20210314050610943.png)

![image-20210314050619244](media/image-20210314050619244.png)

##### `CommonAnnotationBeanPostProcessor#postProcessProperties`

对于@Resource注解，和上面都是一样的。

#### 引用循环依赖的解决过程

在`AutowiredFieldElement#inject`的

![image-20210314045731539](media/image-20210314045731539.png)

这里会触发依赖对象的beanFactory.getBean，上面说的情况是没有循环依赖的。

不过如果有这样的一种依赖情况—— A->B->A，这种也就是循环依赖的情况。

依赖情况—— A->B->A

一开始调用了A的`doGetBean`方法，接着又触发了B的`doGetBean`，由于循环依赖的关系，B的`doGetBean`又触发了A的`doGetBean`。这个流程看上去是一个死循环。但是如果在最后的A的`doGetBean`时，直接返回A的对象，而不去触发创建操作那当B拿到A对象，方法就返回了，并完成了Spring Bean的初始化流程，那么当B的`doGetBean`返回后，A也就会继续走其他流程了。下面看Spring源码是怎么实现这一步骤的。

我建立如下的调用顺序：

1. A的`doGetBean`
2. B的`doGetBean`
3. B的`doGetBean`又触发了A的`doGetBean`

由于1在执行`populateBean`方法之前已经创建A这个对象，而且还会调用方法[`addSingletonFactory`](#addSingletonFactory---对理解循环依赖帮助非常大)，建立了Map<A,`() -> getEarlyBeanReference(beanName, mbd, bean)`>这种映射关系。2步骤没问题，看3步骤：

[A的`doGetBean`](#AbstractBeanFactory#getBean)时，会调用

```java
//从缓存中拿实例
Object sharedInstance = getSingleton(beanName);
```

前面简单的讲过这个方法，现在看回这个方法的源码。

```java
public Object getSingleton(String beanName) {
	return getSingleton(beanName, true);
}

protected Object getSingleton(String beanName, boolean allowEarlyReference) {
	//根据beanName从缓存中拿实例
	//先从一级缓存拿
	Object singletonObject = this.singletonObjects.get(beanName);
	//如果bean还正在创建，还没创建完成，其实就是堆内存有了，属性还没有DI依赖注入
	if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
		synchronized (this.singletonObjects) {
			//从二级缓存中拿
			singletonObject = this.earlySingletonObjects.get(beanName);
			//如果还拿不到，并且允许bean提前暴露
			if (singletonObject == null && allowEarlyReference) {
				//从三级缓存中拿到对象工厂
				ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
				if (singletonFactory != null) {
					//从工厂中拿到对象
					singletonObject = singletonFactory.getObject();
					//升级到二级缓存
					this.earlySingletonObjects.put(beanName, singletonObject);
					//删除三级缓存
					this.singletonFactories.remove(beanName);
				}
			}
		}
	}
	return singletonObject;
}
```

由于在1步骤中，A已经在三级缓存有这样一个对象了——`() -> getEarlyBeanReference(beanName, mbd, bean)`。

> 注意，这里的bean的对象就是目标对象，也就是A对象。

也就是说，到这一步时

```java
ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
```

得到的结果是singletonFactory = `() -> getEarlyBeanReference(beanName, mbd, bean)`

接着就执行了

```
singletonObject = singletonFactory.getObject();
```

也就是说，这里实际执行的`getEarlyBeanReference(beanName, mbd, bean)`方法，这个方法是在类`AbstractAutowireCapableBeanFactory`中的。看这个方法

```java
protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {
	Object exposedObject = bean;
	if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
		for (BeanPostProcessor bp : getBeanPostProcessors()) {
			if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
				SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;
				exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);
			}
		}
	}
	return exposedObject;
}
```

又是BeanPostProcessor的应用，而之所以这样，是因为返回的对象不一定是对象本身，比如AOP，它就需要返回一个代理对象了，所以在这才又使用 了这种BeanPostProcessor的应用。

![image-20210314184717848](media/image-20210314184717848.png)

这里会返回A对象，那么回到`getSingleton()`方法，这时会把该对象放入到二级缓存中，并删除三级缓存。`getSingleton()`的流程结束了，看拿到A的对象后做了什么。

![image-20210314190913084](media/image-20210314190913084.png)

最后还调用了`getObjectForBeanInstance`方法，这个方法就是FactoryBean接口的调用入口，暂时不看。else 不进入的话就不会去创建了，所以这里返回了，整个流程就和我一开始说的一样。只要在3这步切断A的createBean步骤就可以切断这个闭环了。

#### 构造函数的循环依赖

Spring是解决不了这种循环依赖的，对于引用的情况，是先创建了对象后才设置引用的。而构造函数的循环依赖是因为这时对象还在创建中，依赖的对象又在创建中。

所以Spring对于构造函数的循环依赖，会直接在启动的时候报错。

不过如果在构造函数上加上@Lazy就可以，因为实例化时获取到的依赖对象是一个代理对象，所以不存在循环依赖。

不过如果@Lazy加载两个类上还会有问题。

#### Bean范围为Pototype的时候的循环依赖

这时bean是不会使用到3级缓存的，在源码[`AbstractBeanFactory#getBean`](#AbstractBeanFactory#getBean)中是没有调用到`DefaultSingletonBeanRegistry#getSingleton`方法的，这个方法就是使用3级缓存的。

![image-20210314201326971](media/image-20210314201326971.png)

该代码块直接调用了`createBean`，那只会触发bean的创建流程。但出现循环依赖，对同一对象的第二次调用`doGetBean`时，会进入到这段代码块:

![image-20210314202306023](media/image-20210314202306023.png)

会直接报错。

#### initializeBean----依赖注入完以后的调用

bean 实例化+ioc依赖注入完以后，会调用某些接口的方法。而`initializeBean`就是处理这个逻辑：

```java
protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {
	if (System.getSecurityManager() != null) {
		AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
			invokeAwareMethods(beanName, bean);
			return null;
		}, getAccessControlContext());
	}
	else {
		//调用Aware方法
		invokeAwareMethods(beanName, bean);
	}

	Object wrappedBean = bean;
	if (mbd == null || !mbd.isSynthetic()) {
		//对类中某些特殊方法的调用，比如@PostConstruct，Aware接口，非常重要 重要程度 ：5
		//ApplicationContextAwareProcessor 对Aware接口的调用如：
		//EnvironmentAware EmbeddedValueResolverAware  ResourceLoaderAware ApplicationEventPublisherAware MessageSourceAware  ApplicationContextAware
		
		//ImportAwareBeanPostProcessor 对ImportAware的支持
		wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
	}

	try {
		//InitializingBean接口，afterPropertiesSet，init-method属性调用,非常重要，重要程度：5
		invokeInitMethods(beanName, wrappedBean, mbd);
	}
	catch (Throwable ex) {
		throw new BeanCreationException(
				(mbd != null ? mbd.getResourceDescription() : null),
				beanName, "Invocation of init method failed", ex);
	}
	if (mbd == null || !mbd.isSynthetic()) {
		//这个地方可能生出代理实例，是aop的入口
		wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
	}

	return wrappedBean;
}
```

一个一个方法看。

##### invokeAwareMethods----BeanNameAware、BeanClassLoaderAware和BeanFactoryAware

```java
private void invokeAwareMethods(String beanName, Object bean) {
	if (bean instanceof Aware) {
		if (bean instanceof BeanNameAware) {
			((BeanNameAware) bean).setBeanName(beanName);
		}
		if (bean instanceof BeanClassLoaderAware) {
			ClassLoader bcl = getBeanClassLoader();
			if (bcl != null) {
				((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);
			}
		}
		if (bean instanceof BeanFactoryAware) {
			((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);
		}
	}
}
```

这个方法是对实现了这些接口的类的方法调用。

- BeanNameAware
- BeanClassLoaderAware
- BeanFactoryAware

##### applyBeanPostProcessorsBeforeInitialization---非常重要的一个方法

对类中某些特殊方法的调用，比如@PostConstruct，Aware接口，非常重要 重要程度 ：5

```java
public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)
		throws BeansException {

	Object result = existingBean;
	for (BeanPostProcessor processor : getBeanPostProcessors()) {
		Object current = processor.postProcessBeforeInitialization(result, beanName);
		if (current == null) {
			return result;
		}
		result = current;
	}
	return result;
}
```

又是`BeanPostProcessor`的运用，会调用`BeanPostProcessor#postProcessBeforeInitialization`方法

![image-20210314052249704](media/image-20210314052249704.png)

有很多，我们只关注一些类

- InitDestroyAnnotationBeanPostProcessor——@PostConstruct

  ![image-20210314052448907](media/image-20210314052448907.png)

  ![image-20210504043518624](media/image-20210504043518624.png)

  ![image-20210504043526915](media/image-20210504043526915.png)

  这里会去调用加了这个@PostConstruct的方法。

  该类是CommonAnnotationBeanPostProcessor的父类，CommonAnnotationBeanPostProcessor会在`AnnotationConfigUtils#registerAnnotationConfigProcessors`方法中，加入到Spring中，也就是在创建BeanDefinition阶段。

- ApplicationContextAwareProcessor——又是Aware接口调用
  ![image-20210314052924616](media/image-20210314052924616.png)

  ```java
  private void invokeAwareInterfaces(Object bean) {
  	if (bean instanceof EnvironmentAware) {
  		((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());
  	}
  	if (bean instanceof EmbeddedValueResolverAware) {
  		((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);
  	}
  	if (bean instanceof ResourceLoaderAware) {
  		((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);
  	}
  	if (bean instanceof ApplicationEventPublisherAware) {
  		((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);
  	}
  	if (bean instanceof MessageSourceAware) {
  		((MessageSourceAware) bean).setMessageSource(this.applicationContext);
  	}
  	if (bean instanceof ApplicationContextAware) {
  		((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);
  	}
  }
  ```

  挺简单的，就是会去调用这些接口的方法

  1. EnvironmentAware
  2. EmbeddedValueResolverAware
  3. ResourceLoaderAware
  4. ApplicationEventPublisherAware
  5. MessageSourceAware
  6. ApplicationContextAware

  这个是在AbstractApplicationContext.refresh方法中调用的`prepareBeanFactory`方法中添加进去的
  
- ImportAwareBeanPostProcessor

  ![image-20210314053429338](media/image-20210314053429338.png)
  调用了ImportAware的方法

  比如这样写了一个类![image-20210314055756895](media/image-20210314055756895.png)

  是触发不到![image-20210314055919519](media/image-20210314055919519.png)
  这段代码的，需要这样写
  ![image-20210314060042187](media/image-20210314060042187.png)
  ![image-20210314060057865](media/image-20210314060057865.png)
  也就是说只有通过@Import()注解注入的类才能调用到`ImportAware#setImportMetadata`方法。为什么会这样，这就涉及到这个类`ConfigurationClassPostProcessor`。这个类在之后会说。
  
  这个是类是通过`ConfigurationClassPostProcessor`的`postProcessBeanFactory`方法加入进来的，也就是在Spring bean初始化之前。而`ConfigurationClassPostProcessor`又是通过`AnnotationConfigUtils#registerAnnotationConfigProcessors`加入进来的。
  
- ServletContextAwareProcessor——ServletContextAware，ServletConfigAware

  这是使用在使用Spring MVC的时候才会被加入到Spring中。

##### invokeInitMethods----InitializingBean

InitializingBean接口，afterPropertiesSet，init-method属性调用,非常重要，重要程度：5

```java
protected void invokeInitMethods(String beanName, Object bean, @Nullable RootBeanDefinition mbd)
		throws Throwable {

	boolean isInitializingBean = (bean instanceof InitializingBean);
	if (isInitializingBean && (mbd == null || !mbd.isExternallyManagedInitMethod("afterPropertiesSet"))) {
		......
		if (System.getSecurityManager() != null) {
			try {
				AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () -> {
					((InitializingBean) bean).afterPropertiesSet();
					return null;
				}, getAccessControlContext());
			}
			catch (PrivilegedActionException pae) {
				throw pae.getException();
			}
		}
		else {
			//调用实现了InitializingBean接口的方法
			((InitializingBean) bean).afterPropertiesSet();
		}
	}

	if (mbd != null && bean.getClass() != NullBean.class) {
		String initMethodName = mbd.getInitMethodName();
		if (StringUtils.hasLength(initMethodName) &&
				!(isInitializingBean && "afterPropertiesSet".equals(initMethodName)) &&
				!mbd.isExternallyManagedInitMethod(initMethodName)) {
			//调用init-method配置的方法
			invokeCustomInitMethod(beanName, bean, mbd);
		}
	}
}
```

从源码可以看到，会调用`InitializingBean`接口的方法和bean标签的init-method方法。

##### applyBeanPostProcessorsAfterInitialization----是aop的入口

这个地方可能生出代理实例，是aop的入口

前面有个`applyBeanPostProcessorsBeforeInitialization`方法，这个叫AfterI，很明显又是`BeanPostProcessor`接口的应用。

![image-20210314061917247](media/image-20210314061917247.png)

看了这么多`BeanPostProcessor`了，都是在循环中的，而且都是对一个Bean循环的，可以看到，如果某个类对对应的方法感兴趣了，就在对应的方法了做一些对类的操作，不感兴趣了就直接返回就好了。而且，`BeanPostProcessor`这种使用方式感觉就是使用了装饰器模式，虽然没有装饰器模式的形，但有装饰器模式模式的魂----给原始类添加增强功能

这里先讲一个类`ApplicationListenerDetector`。

我们之前讲过

![image-20210314063047133](media/image-20210314063047133.png)

`ApplicationListener`接口的，也就是监听类。这个监听类就是在`ApplicationListenerDetector#postProcessAfterInitialization`方法添加到applicationContext的事件管理类中的。（注意这里是实现接口，但注解的情况在这里没有处理，注解的情况后面会说）

![image-20210314063353992](media/image-20210314063353992.png)

还有一个`AnnotationAwareAspectJAutoProxyCreator`这个是AOP的入口方法，详情看这两节

1. [08-Spring-AOP概念](./08-Spring-AOP概念)
2. [09-Spring-AOP解析](./09-Spring-AOP解析)

#### registerDisposableBeanIfNecessary---注册DisposableBeanAdapter

> ```
> 注册bean销毁时的类DisposableBeanAdapter
> ```

![image-20210314204615965](media/image-20210314204615965.png)

代码很简单`registerDisposableBean`就是在下面的Map中建立<beanName, DisposableBeanAdapter>这种映射关系。

![image-20210314204640118](media/image-20210314204640118.png)

DisposableBeanAdapter就是用于bean销毁（这里的销毁不是触发GC，而是Spring结束前对bean做的一些操作）的实例

`DisposableBeanAdapter`的构造函数做如下操作

1. 是否有实现了接口`DisposableBean`和AutoCloseable
2. 在bean标签中是否定义了destroy-method属性
3. 获取到对象中有@PreDestory注解的方法。

什么时候触发的？手动这样触发的

![image-20210314210742910](media/image-20210314210742910.png)

Tomcat启动时，`AbstractReactiveWebInitializer`这个类里面会为Tomcat添加一个`ServletContextListener`，当tomcat触发close方法时，会调用`contextDestroyed`方法

```java
@Override
public void contextDestroyed(ServletContextEvent sce) {
	this.applicationContext.close();
}

@Override
public void close() {
	synchronized (this.startupShutdownMonitor) {
    // 这里会调用getBeanFactory().destroySingletons();
    // destroySingletonsa会去触发DisposableBeanAdapter的destroy方法
		doClose();
		// If we registered a JVM shutdown hook, we don't need it anymore now:
		// We've already explicitly closed the context.
		if (this.shutdownHook != null) {
			try {
				Runtime.getRuntime().removeShutdownHook(this.shutdownHook);
			}
			catch (IllegalStateException ex) {
				// ignore - VM is already shutting down
			}
		}
	}
}

```



### DefaultSingletonBeanRegistry#getSingleton ----Bean创建完成后

看[`DefaultSingletonBeanRegistry#getSingleton`](#DefaultSingletonBeanRegistry#getSingleton)代码，上面的都只是这个调用的过程

```java
//把beanName添加到singletonsCurrentlyInCreation Set容器中，在这个集合里面的bean都是正在实例化的bean
beforeSingletonCreation(beanName);
```

![image-20210314171229160](media/image-20210314171229160.png)

接着调用

```java
afterSingletonCreation(beanName);

protected void afterSingletonCreation(String beanName) {
	if (!this.inCreationCheckExclusions.contains(beanName) && !this.singletonsCurrentlyInCreation.remove(beanName)) {
    //抛出IllegalStateException
    .....
	}
}
```

之前的`beforeSingletonCreation`是把beanName添加到singletonsCurrentlyInCreation Set容器中，表示这个Bean正在创建；而创建完成后，就调用了`afterSingletonCreation`方法，把beanName在singletonsCurrentlyInCreation Set容器中移除，表示Bean已经创建完成了。

最后调用了

```java
if (newSingleton) {
   //创建对象成功时，把对象缓存到singletonObjects缓存中,bean创建完成时放入一级缓存
   addSingleton(beanName, singletonObject);
}

protected void addSingleton(String beanName, Object singletonObject) {
	synchronized (this.singletonObjects) {
		//一级缓存
		this.singletonObjects.put(beanName, singletonObject);
		//三级缓存
		this.singletonFactories.remove(beanName);
		//二级缓存
		this.earlySingletonObjects.remove(beanName);
		this.registeredSingletons.add(beanName); //这是设计到统计的
	}
}
```

把创建好的Bean放入到一级缓存singletonObjects中，并把二、三级缓存删掉。

总结下这个方法的作用，就是在缓存中没有对象的时候会去调用jvm的对象创建流程，创建完成成后，封装一个ObjectFactory并放入三级缓存中，在三级缓存建立<beanName, ObjectFactory>这样的对应关系，当处理IOC和DI时，如果出现循环依赖就通过三级缓存的ObjectFactory获取到之前已经创建好的jvm对象，并移出三级缓存进入二级缓存。最后IOC和DI处理完，并且对应接口的调用也调用完了，就把bean放入到一级缓存中，并移除二级、三级缓存对应的值。而对象创建的流程时通过方法createBean实现的，并不是`getSingleton`的逻辑。`getSingleton`的核心逻辑就是只是使用了singletonObjects 这个一级缓存。

## 放入一级缓存

Bean初始化完成后，也就是`AbstractBeanFactory#createBean`方法调用完成后，

![image-20211201225853366](media/image-20211201225853366.png)

这时会返回对象，也就是DefaultSingletonBeanRegistry的getSingleton方法中

![image-20211201230116104](media/image-20211201230116104.png)

这代码执行完成了。最后就是执行了这些方法

![image-20211201230203586](media/image-20211201230203586.png)

```java
protected void addSingleton(String beanName, Object singletonObject) {
	synchronized (this.singletonObjects) {
		//一级缓存
		this.singletonObjects.put(beanName, singletonObject);
		//三级缓存
		this.singletonFactories.remove(beanName);
		//二级缓存
		this.earlySingletonObjects.remove(beanName);
		this.registeredSingletons.add(beanName); //这是设计到统计的
	}
}
```

上边的是只有scope="Singleton"时才会执行到，也就是说只有时单例模式，spring才会缓存对象。如果是`prototype`，也就是多例的时候，是不会用到缓存的。看源码

```java
//AbstractBeanFactory#doGetBean
else if (mbd.isPrototype()) {
	// It's a prototype -> create a new instance.
	Object prototypeInstance = null;
	try {
		beforePrototypeCreation(beanName);
		prototypeInstance = createBean(beanName, mbd, args);
	}
	finally {
		afterPrototypeCreation(beanName);
	}
	//该方法是FactoryBean接口的调用入口
	bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
}
```

可以看到，对于多例它是直接createBean的，没有通过getSingleton方法，来缓存。

## 实现`FactoryBean`接口的类的实例化

这个和`FactoryBean`接口有关

`FactoryBean`接口的`getObject`在这个类实例化过程中是不会调用`getObject`方法的，只有在需要使用`getObject`返回对象时才会去调用这个方法。

回到refresh()方法。跟踪代码：

```
AbstractApplicationContext#refresh -->
AbstractApplicationContext#finishBeanFactoryInitialization --> 
DefaultListableBeanFactory#preInstantiateSingletons
```

看`DefaultListableBeanFactory#preInstantiateSingletons`部分源码

![image-20210315002901061](media/image-20210315002901061.png)

这个if就是判断是否实现了FactoryBean接口，这里就看if代码块的代码，先看

```java
String FACTORY_BEAN_PREFIX = "&";

Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
```

也就是说，对于FactoryBean类，在调用getBean时会使用`&beanName`这种形式去找bean

![image-20210315003728277](media/image-20210315003728277.png)

![image-20210315003844685](media/image-20210315003844685.png)

这时，经过`transformedBeanName`又去掉了&符号，并把这个值赋给了新引用。

我们找的目标bean的名字就是beanName引用的指向的字符串。而且这个beanName是有对应的BeanDefinition，这个BeanDefinition指向的类是实现了FactoryBean接口的。所以如果走完Bean的初始化流程，那初始化出来的对象的类型肯定不是我们的目标类型。而是实现了FactoryBean接口类的类型

> 下图返回的是一个代理对象，之所以是代理是因为如果不是代理对象的情况下，直接返回FactoryBean接口对象，那么如果程序通过&baenName获取到该FactoryBean对象，接着通过这个对象调用getObject()方法，那么就会产生一个新的目标对象，这和Spring中bean的范围为singleton相矛盾了，所以这里返回的代理对象，就算程序通过&baenName获取FactoryBean对象，由于这个FactoryBean对象是代理对象，那么在调用getObject()时就能做一些前置处理，比如检查目标对象是否在缓存中存在，如果存在就直接返回就行了。

![image-20210315005300496](media/image-20210315005300496.png)

也就是说，在这个时候在一级缓存singletonObjects 这个Map中就存在一个这样的关系

```
<beanName, FactoryBean接口类（代理）>
```

接着会执行这个方法

```
AbstractBeanFactory.getObjectForBeanInstance(sharedInstance, name, beanName, mbd)
```

调用这个方法的时候name=&beanName， beanName=beanName的，这从上图就已经证明。

```java
protected Object getObjectForBeanInstance(
		Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) {

	// Don't let calling code try to dereference the factory if the bean isn't a factory.
  // 检查是否以&开头
	if (BeanFactoryUtils.isFactoryDereference(name)) {
		if (beanInstance instanceof NullBean) {
			return beanInstance;
		}
		if (!(beanInstance instanceof FactoryBean)) {
			throw new BeanIsNotAFactoryException(beanName, beanInstance.getClass());
		}
		if (mbd != null) {
			mbd.isFactoryBean = true;
		}
		return beanInstance;
	}
  
  .....
}
```

那么在上边的情况这时`if (BeanFactoryUtils.isFactoryDereference(name)) 为true，就直接放回了。所以当通过&beanName获取到的对象为FactoryBean的对象。此时，这个bean的初始化就已经结束了。下面看FactoryBean.getObject方法是什么时候调用的。

假如某个类的定义如下

```java
@Component("bObject")
public AFactoryBean implements FactoryBean<BObject> {
  	.....
    public BObject getObject() throws Exception {
      renturn new BObject();
    }
  	....
}

@Component
public C {
  
  @Autowire
  private BObject bObject;
}
```

那么在该类C的DI阶段，就会调用beanFactory.getBean("bObject")，那么此时

![image-20211201223800480](media/image-20211201223800480.png)

```java
Object sharedInstance = getSingleton("bObject");
```

这代码会返回一个对象，而且这个对象是AFactoryBean，此时进入到`getObjectForBeanInstance`方法。

```java
protected Object getObjectForBeanInstance(
		Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) {

	// Don't let calling code try to dereference the factory if the bean isn't a factory.
	// 检查是否以&开头
	if (BeanFactoryUtils.isFactoryDereference(name)) {
		if (beanInstance instanceof NullBean) {
			return beanInstance;
		}
		if (!(beanInstance instanceof FactoryBean)) {
			throw new BeanIsNotAFactoryException(beanName, beanInstance.getClass());
		}
		if (mbd != null) {
			mbd.isFactoryBean = true;
		}
		return beanInstance;
	}

	// Now we have the bean instance, which may be a normal bean or a FactoryBean.
	// If it's a FactoryBean, we use it to create a bean instance, unless the
	// caller actually wants a reference to the factory.
	//如果实例不是FactoryBean类型的
	if (!(beanInstance instanceof FactoryBean)) {
		return beanInstance;
	}

	//如果代码能走下来，则说明 beanName不是以&开头，并且beanInstance是FactoryBean类型的
	Object object = null;
	if (mbd != null) {
		mbd.isFactoryBean = true;
	}
	else {
		//从缓存里面拿FactoryBean类型的实例
		object = getCachedObjectForFactoryBean(beanName);
	}
	if (object == null) {
		// Return bean instance from factory.
		FactoryBean<?> factory = (FactoryBean<?>) beanInstance;
		// Caches object obtained from FactoryBean if it is a singleton.
		if (mbd == null && containsBeanDefinition(beanName)) {
			mbd = getMergedLocalBeanDefinition(beanName);
		}
		boolean synthetic = (mbd != null && mbd.isSynthetic());
		//重点看
		object = getObjectFromFactoryBean(factory, beanName, !synthetic);
	}
	return object;
}
```

由于beanName是bObject，所以不会进入到if代码，那么此时最后会走到这代码块

![image-20211201225111140](media/image-20211201225111140.png)

重点看

```java
object = getObjectFromFactoryBean(factory, beanName, !synthetic);
```

![image-20210315011643696](media/image-20210315011643696.png)

先从缓存`factoryBeanObjectCache`

![image-20210315011722171](media/image-20210315011722171.png)

中拿，没有就执行下边的`doGetObjectFromFactoryBean`方法

![image-20210315011757025](media/image-20210315011757025.png)

这个方法放回后，想都不用想，就是把拿到的目标对象放到缓存`factoryBeanObjectCache`中。下次再通过beanName就可以直接在缓存`factoryBeanObjectCache`中获取了。

而如果这时时通过&beanName去获取bean，那么进入`doGetBean`时会把&去掉后获取到一个实现FactoryBean类型类的对象，之后进入getObjectForBeanInstance(sharedInstance, name, beanName, mbd)时由于BeanFactoryUtils.isFactoryDereference(name)为true，所以就直接返回了实现FactoryBean类型类的对象了（注意，这个是代理对象）。

### FactoryBean的应用场景

可以提供用户自己定义实例化



## 在Spring中如果你想创建一个对象，对象能被Spring管理

1. 自定义BeanDefination，通过BeanDefinitionRegistryPostProcessor接口
2. ![image-20210315013433388](media/image-20210315013433388.png)
3. 实现FactoryBean
4. @Bean

## Spring bean初始化完成后——放入到一级缓存之后，执行SmartInitializingSingleton接口

回到`DefaultListableBeanFactory#preInstantiateSingletons()`

![image-20210504052036554](media/image-20210504052036554.png)

在这里会调用接口SmartInitializingSingleton的方法。

这里说一个类就是`EventListenerMethodProcessor`。

### EventListenerMethodProcessor——@EventListener注解的解析

[Spring Event事件通知机制](./Spring Event事件通知机制)

## Spring初始化流程中的三级缓存

在Spring的初始化流程会使用到三级缓存

```java
private final Map<String, Object> singletonObjects = new ConcurrentHashMap(256);
private final Map<String, Object> earlySingletonObjects = new HashMap(16);
private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap(16);
```

其中`singletonObjects`就是最缓存最终的对象的。而`earlySingletonObjects`和`singletonFactories`相互配合使用，完成了Bean的初始化流程

比如：存在这样一个类

```
class A {
	@Autowrite
  A a;
}
```

首先一个，在beanFactory.getBean(A)的时候，

1. new A

2. 收集A中的注解信息（@Autowrite、@Resource、@Value和@PostConstruct等注解信息）

3. 创建一个包含A对象引用的ObjectFactory对象，并把这个对象放入3级缓存中。

4. `populateBean`，完成Bean的填充（DI依赖注入）和`@PostConstruct`等注解的处理

   在处理依赖注入时，本质上就是进行beanFactory#getBean，所以对于A对象的依赖注入，会进行beanFactory.getBean(a)

   1. 从三级缓存中一级一级的拿对象，最终在第三级`singletonFactories`中获取到一个ObjectFactory对象。然后会执行ObjectFactory#getObject。
   2. 会对ObjectFactory对象中的A对象进行`AbstractAutoProxyCreator#getEarlyBeanReference`，也就是进行切面的匹配，匹配到的话就生成代理对象。
   3. 把第二步中返回的A对象（或A对像的代理对象）放入二级缓存，并移除3级缓存（这时二级缓存已经是最终的对象了）
   4. 把第3步的对象返回，作为A对象中a属性引用的对象。

5. 对A对象进行`initializeBean`，并返回A对象（或A对像的代理对象）

   1. BeanPostProcessor#postProcessBeforeInitialization的执行，包括对`ApplicationEventPublisherAware`、`ApplicationContextAware`等接口的处理和`@PostConstruct`的等注解的处理

   2. 执行`InitializingBean#afterPropertiesSet`

   3. BeanPostProcessor#postProcessAfterInitialization的执行，并返回A对象（或A对像的代理对象）

      最重要的就是`AbstractAutoProxyCreator`，完成切面匹配和代理类生成。对于A对象，由于在4.2中已经执行过这一步了，所以这里不会重复执行，会直接返回A对象。

6. 会从二级缓存拿对象，如果没有就直接返回A对象。如果有就返回二级缓存对象（A对象或者A对像的代理对象）

   对于没有的情况，是不存在循环依赖才会出现这种情况，而对于有的情况，就意味着有循环引用。

   对于A对象，由于在第4步中提前完成了切面匹配和代理对象的生成，所以这里会返回A对象（或A对像的代理对象）

7. 把第6步返回的对象（A对象或者A对像的代理对象）放入到一级缓存中，并移除二三级缓存对应的内容。

从这个过程可以看出，三级缓存`singletonFactories`就是用来避免循环依赖时，重复触发creaetBean的问题，并且会对Bean提交进行包装（AOP）。而二级缓存`earlySingletonObjects`存放提前完成包装的对象（AOP），并负责提前暴露给其他bean。

## Spring Bean初始化流程图

![Bean实例化过程](media/Bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B.jpg)

## Spring Bean 循环依赖的流程图

![spring中单例实例的循环依赖](media/spring%E4%B8%AD%E5%8D%95%E4%BE%8B%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.jpg)

