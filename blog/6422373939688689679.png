

# BeanPostProcessor

![image-20210315214807314](media/image-20210315214807314.png)



# BeanDefinitionRegistryPostProcessor

解析看这里[02-Spinrg的后置处理器-BeanDefinitionRegistryPostProcessor调用时机](./02-Spinrg的后置处理器-BeanDefinitionRegistryPostProcessor调用时机)

![image-20210313025629475](media/image-20210313025629475.png)

先看下定义：

![image-20210313025557942](media/image-20210313025557942.png)

![image-20210313025640669](media/image-20210313025640669.png)

从refresh，可以看到在执行`invokeBeanFactoryPostProcessors`方法的时候，这个时间短只是完成了BeanDefinition的创建和注册到BeanFactory中而已。而且从接口`BeanDefinitionRegistryPostProcessor`定义的抽象方法可以看到，它们都是带着注册中心的，也就是说，这个借口的实现类完全可以获取到之前创建并注册完成的BeanDefinition！那我们可以做一些扩展，比如自己再注册个BeanDefinition或者修改下BeanDefinition也可以去实现扫描我们自定义的注解！也就是要增删改查BeanDefinition时可以实现这个接口！

这里定义了两个抽象方法，不过这两个方法的调用时机是不同的。从方法名可以了解一些信息

- `postProcessBeanDefinitionRegistry`的重点是对BeanDefinition的处理
- `postProcessBeanFactory`的重点是对BeanFactory对象属性的修改

参考类：

```java
@Component
public class BeanPro implements BeanDefinitionRegistryPostProcessor, PriorityOrdered, Ordered {
    @Override
    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
        //查询BeanDefinition
        final String[] beanDefinitionNames = registry.getBeanDefinitionNames();
        for (String beanDefinitionName : beanDefinitionNames) {
            BeanDefinition beanDefinition = registry.getBeanDefinition(beanDefinitionName);
            System.out.println(beanDefinition);
        }

        GenericBeanDefinition genericBeanDefinition = new GenericBeanDefinition();
        genericBeanDefinition.setBeanClass(BeanDefinitionBean.class);
        MutablePropertyValues propertyValues = genericBeanDefinition.getPropertyValues();
        propertyValues.add("name","Jack");
        registry.registerBeanDefinition("beanDefinitionBean",genericBeanDefinition);


//        ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(registry);
//        //需要过滤的注解
//        scanner.addIncludeFilter(new AnnotationTypeFilter(MyService.class));
//        scanner.scan("com.enjoy.jack.customBean");
    }

    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
        String[] beanDefinitionNames = registry.getBeanDefinitionNames();

        DefaultListableBeanFactory beanFactory1 = (DefaultListableBeanFactory)beanFactory;
        beanFactory1.setAllowBeanDefinitionOverriding(true);
        beanFactory1.setAllowCircularReferences(true);
        beanFactory1.setAllowRawInjectionDespiteWrapping(true);
    }

    @Override
    public int getOrder() {
        return 0;
    }
}
```



# SmartInstantiationAwareBeanPostProcessor

这个是看这里[实例化带有@Autowired注解的构造函数](./04-Spring的Bean实例化#实例化带有#Autowired注解的构造函数)

这个接口出了上边的作用还有

[引用循环依赖的解决过程](./04-Spring的Bean实例化)

# MergedBeanDefinitionPostProcessor

这个是看这里[收集注解--applyMergedBeanDefinitionPostProcessors](./04-Spring的Bean实例化#实例化带有#applyMergedBeanDefinitionPostProcessors)



# InstantiationAwareBeanPostProcessor

这个看这里[ioc di（控制反转），依赖注入的核心方法----populateBean](./04-Spring的Bean实例化#populateBean)



# DestructionAwareBeanPostProcessor

看[registerDisposableBeanIfNecessary---bean销毁前需要做的操作类DisposableBeanAdapter]((./04-Spring的Bean实例化#populateBean))



# AbstractAutowireCapableBeanFactory

记住这个类，它定义基于注解的的bean的初始化阶段的整个流程。



# BeanPostProcessor

非常重要的一个接口，贯穿了Spring的bean的初始化流程和功能的扩展

看这这么多`BeanPostProcessor`了，都是在循环中的，而且都是对一个Bean循环的，可以看到，如果某个类对对应的方法感兴趣了，就在对应的方法了做一些对类的操作，不感兴趣了就直接返回就好了。而且，`BeanPostProcessor`这种使用方式感觉就是使用了装饰器模式，虽然没有装饰器模式的形，但有装饰器模式模式的魂----给原始类添加增强功能



# ApplicationListener

```java
@Component
@Order(2)
public class EnjoyApplicationListener1 implements ApplicationListener {
    @Override
    public void onApplicationEvent(ApplicationEvent event) {
        if(event instanceof EnjoyEvent) {
            System.out.println("==EnjoyApplicationListener1");
        }
    }
}
```

或者使用注解

![image-20210313223555866](media/image-20210313223555866.png)

![image-20210313224714819](media/image-20210313224714819.png)



# Spring Bean完成依赖注入后调用的接口

按顺序（有部顺序是不对的）：

1. BeanNameAware

2. BeanClassLoaderAware

3. BeanFactoryAware

4. InitDestroyAnnotationBeanPostProcessor#postProcessBeforeInitialization----处理@PostConstruct

5. EnvironmentAware

6. EmbeddedValueResolverAware

7. ResourceLoaderAware

8. ApplicationEventPublisherAware

9. MessageSourceAware

10. ApplicationContextAware

11. ImportAware比如这样写了一个类![image-20210314055756895](media/image-20210314055756895.png)

    是触发不到![image-20210314055919519](media/image-20210314055919519.png)
    这段代码的，需要这样写
    ![image-20210314060042187](media/image-20210314060042187.png)
    ![image-20210314060057865](media/image-20210314060057865.png)
    也就是说只有通过@Import()注解注入的类才能调用到`ImportAware#setImportMetadata`方法。这个原因就是在收集注解的BeanPostProcessor，也就是`ConfigurationClassPostProcessor`来完成收集，这个过程是发生在BeanDefinition创建阶段的。完成了Spring bean的依赖注入（DI)阶段后，也就是调用`AbstractAutowireCapableBeanFactory#initializeBean`中时，会调用`ImportAwareBeanPostProcessor`接口的`postProcessBeforeInitialization`方法来完成`ImportAware`接口的调用。

11. ServletContextAware，ServletConfigAware

12. InitializingBean

13. 调用init-method配置的方法

15. 调用方法`ApplicationListenerDetector#postProcessAfterInitialization`把之前注册的事件--`ApplicationListener`注册到事件管理器中

16. DisposableBean，AutoCloseable在JVM关闭前，调用的方法。

17. 



# Spring Bean初始化完成后调用的接口方法

1. SmartInitializingSingleton

   在初始化入口方法`DefaultListableBeanFactory#preInstantiateSingletons` 执行完getBean后：

   ![image-20210504040319430](media/image-20210504040319430.png)

# ImportSelector、DeferredImportSelector和ImportBeanDefinitionRegistrar

看[07-Spring中基于注解--ConfigurationClassPostProcessor](./07-Spring中基于注解--ConfigurationClassPostProcessor#处理@Import注解)

都是引入类，交给Spring管理

