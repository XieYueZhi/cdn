# Spring配置的解析

在Spring中，Spring会把配置内容保存到`Environment`中。而这个`Environment`内容的对象类型为`StandardEnvironment`。的创建采用的延迟创建的模式，只有当点用ApplicationContext的**getEnvironment**方法时才会传遍。源码为

```java
//AbstractApplicationContext
@Override
public ConfigurableEnvironment getEnvironment() {
	if (this.environment == null) {
		this.environment = createEnvironment();
	}
	return this.environment;
}

protected ConfigurableEnvironment createEnvironment() {
	return new StandardEnvironment();
}
```



## xml对配置的解析

传统手艺xml

```xml
<context:property-placeholder location="classpath:application.properties"/>
```

现在找property-placeholder这个是那个类解析的，流程就是通过context，找到URI，通过URi找到对应的NamespaceHandlerSupport，再看该类的init方法，根据key找到BeanDefinitionParser

最终找到了property-placeholder的解析类是`PropertyPlaceholderBeanDefinitionParser`，看下该类的定义:

![image-20210314215101273](media/image-20210314215101273.png)

看`getBeanClass`，该方法会返回一个解析的关键类，会返回一个`PropertySourcesPlaceholderConfigurer.class`对象

![image-20210314215259666](media/image-20210314215259666.png)

为什么说它重要呢？因为在对自定义标签的解析中，会去到`PropertyPlaceholderBeanDefinitionParser`后会调用parser方法，在该类调用的parser方法中就是调用了`getBeanClass`方法，并且会创建一个`GenericBeanDefinition`然后注册到beanFactory中，那么在BeanDefinition初始化和注册完成后，就会去找实现了`BeanFactoryPostProcessor`接口的BeanDefinition，然后实例化并调用方法postProcessBeanFactory方法。

看`PropertySourcesPlaceholderConfigurer`的类图

![image-20210314222904091](media/image-20210314222904091.png)

实现了BeanFactoryPostProcessor接口，那么会在BeanDefinition初始化和注册完成后就会调用该接口的方法，看方法

```java
public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
	if (this.propertySources == null) {
		this.propertySources = new MutablePropertySources();
		if (this.environment != null) {
			//把environment对象封装成的PropertySource对象加入到
			this.propertySources.addLast(
					//把environment对象封装成PropertySource对象MutablePropertySources中的list中
				new PropertySource<Environment>(ENVIRONMENT_PROPERTIES_PROPERTY_SOURCE_NAME, this.environment) {
					@Override
					@Nullable
					//source就是environment对象
					public String getProperty(String key) {
						return this.source.getProperty(key);
					}
				}
			);
		}
		try {
			//加载本地配置文件中的属性值包装成properties对象后，最终包装成PropertySource对象
			PropertySource<?> localPropertySource =
					new PropertiesPropertySource(LOCAL_PROPERTIES_PROPERTY_SOURCE_NAME, mergeProperties());
			//加入到MutablePropertySources中的list中
			if (this.localOverride) {
				this.propertySources.addFirst(localPropertySource);
			}
			else {
				this.propertySources.addLast(localPropertySource);
			}
		}
		catch (IOException ex) {
			throw new BeanInitializationException("Could not load properties", ex);
		}
	}

	processProperties(beanFactory, new PropertySourcesPropertyResolver(this.propertySources));
	this.appliedPropertySources = this.propertySources;
}

protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess,
		final ConfigurablePropertyResolver propertyResolver) throws BeansException {

	//设置占位符的前缀后缀
	propertyResolver.setPlaceholderPrefix(this.placeholderPrefix);
	propertyResolver.setPlaceholderSuffix(this.placeholderSuffix);
	//设分割符 :
	propertyResolver.setValueSeparator(this.valueSeparator);

	//重点是这个匿名对象 @Value的依赖注入会掉过来
	StringValueResolver valueResolver = strVal -> {
		String resolved = (this.ignoreUnresolvablePlaceholders ?
				propertyResolver.resolvePlaceholders(strVal) :
				propertyResolver.resolveRequiredPlaceholders(strVal));
		if (this.trimValues) {
			resolved = resolved.trim();
		}
		return (resolved.equals(this.nullValue) ? null : resolved);
	};
	//核心流程。把占位符${xxx}替换成真正的值
	doProcessProperties(beanFactoryToProcess, valueResolver);
}

protected void doProcessProperties(ConfigurableListableBeanFactory beanFactoryToProcess,
		StringValueResolver valueResolver) {

	//beanDefinition的修改者
	BeanDefinitionVisitor visitor = new BeanDefinitionVisitor(valueResolver);

	//获取所有的beanNames
	String[] beanNames = beanFactoryToProcess.getBeanDefinitionNames();
	for (String curName : beanNames) {
		// Check that we're not parsing our own bean definition,
		// to avoid failing on unresolvable placeholders in properties file locations.
		if (!(curName.equals(this.beanName) && beanFactoryToProcess.equals(this.beanFactory))) {
			//获取BeanDefinition对象
			BeanDefinition bd = beanFactoryToProcess.getBeanDefinition(curName);
			try {
				//修改BeanDefinition中的MutablePropertyValues中的每一个属性值，把属性值有${enjoy.name}修改成真正的参数值
				visitor.visitBeanDefinition(bd);
			}
			catch (Exception ex) {
				throw new BeanDefinitionStoreException(bd.getResourceDescription(), curName, ex.getMessage(), ex);
			}
		}
	}

	// New in Spring 2.5: resolve placeholders in alias target names and aliases as well.
	beanFactoryToProcess.resolveAliases(valueResolver);
	//把内嵌的Value解析器设置到BeanFactory中..为@Value的依赖注入做准备
	// New in Spring 3.0: resolve placeholders in embedded values such as annotation attributes.
	beanFactoryToProcess.addEmbeddedValueResolver(valueResolver);
}
```

看第一个if (this.environment != null)，这个environment对在

![image-20210314224446565](media/image-20210314224446565.png)这

这里创建一个对象

![image-20210314224627711](media/image-20210314224627711.png)

![image-20210314224639507](media/image-20210314224639507.png)

之后执行

`PropertySource<?> localPropertySource = new PropertiesPropertySource(LOCAL_PROPERTIES_PROPERTY_SOURCE_NAME, mergeProperties());`就把项目属性设置好了

该方法核心其实就是走了这种操作

```java
Properties properties = new Properties();
properties.load(new FileInputStream("/Volumes/vm/mq/rockermq/conf/broker.conf"));
System.out.println(properties);
```

最后调用

`processProperties(beanFactory, new PropertySourcesPropertyResolver(this.propertySources));`

跟踪代码最后看核心源码：![image-20210314225125690](media/image-20210314225125690.png)

就是遍历BeanDefinition，然后修改对应的值。

解析的逻辑在这个类中：`PropertyPlaceholderHelper`

感觉配置是如何解析的不是很重要，大致流程了解下即可，也就是`BeanFactoryPostProcessor`接口的应用。

## 通过配置文件实例化bean

```properties
enjoy.name=jack
enjoy.password=123

enjoy.beanClass = ${enjoy.placeHolderBean1},${enjoy.placeHolderBean2},${enjoy.placeHolderBean3}
enjoy.placeHolderBean1 = com.enjoy.jack.beanDefinitionPostProcessor.PlaceHolderBean1
enjoy.placeHolderBean2 = com.enjoy.jack.beanDefinitionPostProcessor.PlaceHolderBean2
enjoy.placeHolderBean3 = com.enjoy.jack.beanDefinitionPostProcessor.PlaceHolderBean3

cn.enjoy.scan.packages=com.xiangxue.jack
cn.enjoy.flag=true
```

比如配置有个文件这样

然后我自己写了个类：

```java
@Component
public class PropertyPlaceHolderBeanDefinition implements BeanDefinitionRegistryPostProcessor {
    @Override
    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
        try {
            Properties properties = PropertiesLoaderUtils.loadAllProperties("application.properties", ClassUtils.getDefaultClassLoader());
            String property = properties.getProperty("enjoy.beanClass");
            String[] beanClasss = property.split(",");
            for (String classs : beanClasss) {
                BeanDefinition beanDefinition = new GenericBeanDefinition();
                beanDefinition.setBeanClassName(classs);
//                String beanName = BeanDefinitionReaderUtils.generateBeanName(beanDefinition,registry);
                registry.registerBeanDefinition(UUID.randomUUID().toString(),beanDefinition);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {

    }
}
```

## @Value注解的依赖注入

就看`AbstarctAutowireCapobleBeanFactory#doCreateBean`中的`populateBean`方法，该方法就是处理依赖注入的

到这里

![image-20210314231119342](media/image-20210314231119342.png)

跟踪代码：

```
AbstractAutowireCapableBeanFactory#populateBean --->
AutowiredAnnotationBeanPostProcessor#postProcessProperties -->
InjectionMetadata#inject -->
AutowiredAnnotationBeanPostProcessor#inject
```

![image-20210314231906450](media/image-20210314231906450.png)

@Autowire在这里会返回bean，但对于@Value不同，看代码：

![image-20210314232006492](media/image-20210314232006492.png)

![image-20210314232028187](media/image-20210314232028187.png)

在`PropertySourcesPlaceholderConfigurer`的源码中传入了一个匿名对象

![image-20210314232315244](media/image-20210314232315244.png)

那getAutowireCandidateResolver()这个就获取了匿名对象了。返回值后就和@Autowire一样了。