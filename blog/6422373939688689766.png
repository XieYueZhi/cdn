# Spring的Bean实例化前的方法

上节讲了BeanDefinitionRegistryPostProcessor的实例化和调用时机。

这节看Bean实例化前执行的一些重要方法。

回到`AbstractApplicationContext#refresh()`方法

```java
	public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
			//为容器初始化做准备，重要程度：0
			// Prepare this context for refreshing.
			prepareRefresh();

			/*
			   重要程度：5
			  1、创建BeanFactory对象
			* 2、xml解析
			* 	传统标签解析：bean、import等
			* 	自定义标签解析 如：<context:component-scan base-package="com.xiangxue.jack"/>
			* 	自定义标签解析流程：
			* 		a、根据当前解析标签的头信息找到对应的namespaceUri
			* 		b、加载spring所有jar中的spring.handlers文件。并建立映射关系
			* 		c、根据namespaceUri从映射关系中找到对应的实现了NamespaceHandler接口的类
			* 		d、调用类的init方法，init方法是注册了各种自定义标签的解析类
			* 		e、根据namespaceUri找到对应的解析类，然后调用paser方法完成标签解析
			*
			* 3、把解析出来的xml标签封装成BeanDefinition对象
			* */
			// Tell the subclass to refresh the internal bean factory.
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			/*
			 * 给beanFactory设置一些属性值，可以不看
			 * */
			// Prepare the bean factory for use in this context.
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
				postProcessBeanFactory(beanFactory);

				/*
				 * BeanDefinitionRegistryPostProcessor
				 * BeanFactoryPostProcessor
				 * 完成对这两个接口的调用
				 * */
				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);

				/*
				 * 把实现了BeanPostProcessor接口的类实例化，并且加入到BeanFactory中
				 * */
				// Register bean processors that intercept bean creation.
				registerBeanPostProcessors(beanFactory);

				/*
				 * 国际化,重要程度2
				 * */
				// Initialize message source for this context.
				initMessageSource();

				//初始化事件管理类
				// Initialize event multicaster for this context.
				initApplicationEventMulticaster();

				//这个方法着重理解模板设计模式，因为在springboot中，这个方法是用来做内嵌tomcat启动的
				// Initialize other special beans in specific context subclasses.
				onRefresh();

				/*
				 * 往事件管理类中注册事件类
				 * */
				// Check for listener beans and register them.
				registerListeners();

				/*
				 * 这个方法是spring中最重要的方法，没有之一
				 * 所以这个方法一定要理解要具体看
				 * 1、bean实例化过程
				 * 2、ioc
				 * 3、注解支持
				 * 4、BeanPostProcessor的执行
				 * 5、Aop的入口
				 * */
				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);

				// Last step: publish corresponding event.
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn("Exception encountered during context initialization - " +
							"cancelling refresh attempt: " + ex);
				}

				// Destroy already created singletons to avoid dangling resources.
				destroyBeans();

				// Reset 'active' flag.
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				// Reset common introspection caches in Spring's core, since we
				// might not ever need metadata for singleton beans anymore...
				resetCommonCaches();
			}
		}
	}
```

## registerBeanPostProcessors(beanFactory)

该方法也是一个很重要的方法，这里会把实现了BeanPostProcessor接口的类实例化，并且加入到BeanFactory中，而BeanPostProcessor的就是spring提供的扩展点接口。

`registerBeanPostProcessors(beanFactory)`：

```java
	public static void registerBeanPostProcessors(
			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {

		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);

		// Register BeanPostProcessorChecker that logs an info message when
		// a bean is created during BeanPostProcessor instantiation, i.e. when
		// a bean is not eligible for getting processed by all BeanPostProcessors.
		int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
		beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));

		// Separate between BeanPostProcessors that implement PriorityOrdered,
		// Ordered, and the rest.
		List<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();
		List<BeanPostProcessor> internalPostProcessors = new ArrayList<>();
		List<String> orderedPostProcessorNames = new ArrayList<>();
		List<String> nonOrderedPostProcessorNames = new ArrayList<>();
		//提前实例化BeanPostProcessor类型的bean，然后bean进行排序
		for (String ppName : postProcessorNames) {
			if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
				//getBean是实例化方法，后面我们在讲bean实例化过程是会着重讲到
				BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
				priorityOrderedPostProcessors.add(pp);
				//判断类型是否是MergedBeanDefinitionPostProcessor，如果是则代码是内部使用的
				if (pp instanceof MergedBeanDefinitionPostProcessor) {
					internalPostProcessors.add(pp);
				}
			}
			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
				orderedPostProcessorNames.add(ppName);
			}
			else {
				nonOrderedPostProcessorNames.add(ppName);
			}
		}

		// First, register the BeanPostProcessors that implement PriorityOrdered.
		sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
		//注册到BeanFactory中
		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);

		// Next, register the BeanPostProcessors that implement Ordered.
		List<BeanPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());
		for (String ppName : orderedPostProcessorNames) {
			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
			orderedPostProcessors.add(pp);
			if (pp instanceof MergedBeanDefinitionPostProcessor) {
				internalPostProcessors.add(pp);
			}
		}
		sortPostProcessors(orderedPostProcessors, beanFactory);
		registerBeanPostProcessors(beanFactory, orderedPostProcessors);

		// Now, register all regular BeanPostProcessors.
		List<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());
		for (String ppName : nonOrderedPostProcessorNames) {
			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
			nonOrderedPostProcessors.add(pp);
			if (pp instanceof MergedBeanDefinitionPostProcessor) {
				internalPostProcessors.add(pp);
			}
		}
		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);

		// Finally, re-register all internal BeanPostProcessors.
		sortPostProcessors(internalPostProcessors, beanFactory);
		registerBeanPostProcessors(beanFactory, internalPostProcessors);

		// Re-register post-processor for detecting inner beans as ApplicationListeners,
		// moving it to the end of the processor chain (for picking up proxies etc).
		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
	}
```

看`String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);`

该方法上节讲过了，就是在beanDefinition注册器(BeanFactory)中获取了实现了BeanPostProcessor接口的类的beanName。

![image-20210313213748569](media/image-20210313213748569.png)

> 还记得名字是这两个的BeanDefinition吗？
>
> `org.springframework.context.annotation.internalAutowiredAnnotationProcessor`
>
> `org.springframework.context.annotation.internalCommonAnnotationProcessor`
>
> 这两个对应的BeanDefinition是RootBeanDefinition，是在扫描的最后一步，也就是扫描完类而且创建好了BeanDefinition和BeanDefinition已经注册完成后，Spring会把名字是这两个的RootBeanDefinition注册到注册器中，而且RootBeanDefinition里面对应的class对象是`CommonAnnotationBeanPostProcessor.class`和`AutowiredAnnotationBeanPostProcessor.class`
>
> 看下这两个类的类图:
>
> `CommonAnnotationBeanPostProcessor`:
>
> ![image-20210313023954299](media/image-20210313023954299.png)
>
> `AutowiredAnnotationBeanPostProcessor`:
>
> ![image-20210313024038039](media/image-20210313024038039.png)

好了代码继续走

![image-20210313214236645](media/image-20210313214236645.png)

这段代码会对实现了BeanPostProcessor的类实例化并进行分类

1. 把实现了PriorityOrdered的分类一类
2. 把实现了Ordered的分类一类
3. 把除上边两种情况外的分为一类

然后会进行排序，排序规则和上一节的BeanDefinitionRegistryPostProcess的排序规则一样，在上边的分类下，对order进行升序排序。

接着执行：

```
registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);
```

![image-20210313214435593](media/image-20210313214435593.png)

```java
public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) {
    Assert.notNull(beanPostProcessor, "BeanPostProcessor must not be null");
    this.beanPostProcessors.remove(beanPostProcessor);
    if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {
        this.hasInstantiationAwareBeanPostProcessors = true;
    }

    if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) {
        this.hasDestructionAwareBeanPostProcessors = true;
    }

    this.beanPostProcessors.add(beanPostProcessor);
}
```

就是把创建的`BeanPostProcessor`对象放入到下面这个集合中。

```
private final List<BeanPostProcessor> beanPostProcessors = new CopyOnWriteArrayList();
```

下面的代码也是同样的逻辑。

`registerBeanPostProcessors(beanFactory);`该方法的作用就是把实现了BeanPostProcessor接口的类实例化，并且加入到BeanFactory中，没别的了。

### BeanPostProcessor的简单介绍

看下BeanPostProcessor接口的定义

![image-20210313223028788](media/image-20210313223028788.png)

接口看上去很简单，但该接口有很多子接口，在子接口中一般情况下是会定义一些default方法，这些default方法是交给实现类来重写的。而通过定义不同的default方法和实现类实现不同的default方法这种方式，来提供丰厚的扩展点。

比如：

[BeanPostProcessor 接口理解](./BeanPostProcessor 接口理解)

[Spring中重要的接口](./00-Spring中重要的接口)



## initApplicationEventMulticaster();——事件处理器`SimpleApplicationEventMulticaster`的创建

源码：

```java
protected void initApplicationEventMulticaster() {
	ConfigurableListableBeanFactory beanFactory = getBeanFactory();
	if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {
		this.applicationEventMulticaster =
				beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);
		//打印日志
    ......
	}
	else {
		this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
		beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);
		//打印日志
    ......
	}
}
```

该方法会创建一个`SimpleApplicationEventMulticaster`对象，并把对象注册到了Spring容器的`singletonObjects`中（`singletonObjects`可以叫一级缓存或单例池）。而`SimpleApplicationEventMulticaster`是Spring的默认事件管理器。

> 详情看[Spring Event事件通知机制](./Spring Event事件通知机制)

## onRefresh();

该方法在Spring中没用，是一个空方法，但在Spring boot中有用。

在spring boot中，这个方法是用来做内嵌Servlet容器（默认是tomcat）的启动的

## registerListeners()——事件监听器注册

源码:

```java
protected void registerListeners() {
	// Register statically specified listeners first.
	for (ApplicationListener<?> listener : getApplicationListeners()) {
		getApplicationEventMulticaster().addApplicationListener(listener);
	}

	// Do not initialize FactoryBeans here: We need to leave all regular beans
	// uninitialized to let post-processors apply to them!
	String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
	for (String listenerBeanName : listenerBeanNames) {
		getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
	}

  // 触发一些应用早期事件
	// Publish early application events now that we finally have a multicaster...
	Set<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;
	this.earlyApplicationEvents = null;
	if (!CollectionUtils.isEmpty(earlyEventsToProcess)) {
		for (ApplicationEvent earlyEvent : earlyEventsToProcess) {
			getApplicationEventMulticaster().multicastEvent(earlyEvent);
		}
	}
}
```

这个方法是添加一些`ApplicationListener`和触发一些`early application events`。

> 对于Spring 的事件通知可以看[Spring Event事件通知机制](./Spring Event事件通知机制)

对于

```java
for (ApplicationListener<?> listener : getApplicationListeners()) {
	getApplicationEventMulticaster().addApplicationListener(listener);
}
```

可以通过下面的方式来添加`ApplicationListener`

![image-20210313230045629](media/image-20210313230045629.png)

对于

```java
	String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
	for (String listenerBeanName : listenerBeanNames) {
		getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
	}

```

这里只是添加了实现了`ApplicationListener`接口的beanName，这里会在`multicastEvent`方法中，触发通过beanName，从Spring容器中获取对象的方法。也就是getBean。

而注册的事件是怎么触发的？可以通过下面的代码触发。

```java
ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring.xml");
applicationContext.publishEvent(new EnjoyEvent("Jack","enjoyEvent"));
```

Spring的事件通知涉及到观察者设计模式。

比如：![image-20210313221939675](media/image-20210313221939675.png)

可以看下publishEvent源码:

![image-20210313224148188](media/image-20210313224148188.png)

![image-20210313224257822](media/image-20210313224257822.png)

可以看到，逻辑就是遍历全部的`ApplicationListener`，最后执行`invokeListener(listener, event)`方法。

看下invokeListener(listener, event)方法

![image-20210313224403441](media/image-20210313224403441.png)

Spring也会发布事件，有这5种标准事件：

![image-20210313224714819](media/image-20210313224714819.png)

比如第一事件ContextRefreshedEvent，在refresh()方法的最后的finishRefresh就有发布这个事件。

![image-20210313225411098](media/image-20210313225411098.png)

所以如果我们自己写一个订阅该事件的类，比如：

![image-20210313225507140](media/image-20210313225507140.png)

也就可以在容器初始化完时做一些操作。

第二个事件ContextStartedEvent

![image-20210313230410683](media/image-20210313230410683.png)

![image-20210313230419747](media/image-20210313230419747.png)

第三个事件ContextStoppedEvent

![image-20210313230458837](media/image-20210313230458837.png)

![image-20210313230507949](media/image-20210313230507949.png)

