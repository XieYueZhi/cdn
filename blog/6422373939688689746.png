# Spinrg的后置处理器-BeanDefinitionRegistryPostProcessor调用时机

以ClassPathXmlApplicationContext为ApplicationContext

```java
public void refresh() throws BeansException, IllegalStateException {
   synchronized (this.startupShutdownMonitor) {
    
     //x去掉了一些和这节无关的代码
     .....
      /*
      * 重要程度：5
      * 1、创建BeanFactory对象
      * 2、xml解析
      *  传统标签解析：bean、import等
      *  自定义标签解析 如：<context:component-scan base-package="com.xiangxue.jack"/>
      *  自定义标签解析流程：
      *     a、根据当前解析标签的头信息找到对应的namespaceUri
      *     b、加载spring所有jar中的spring.handlers文件。并建立映射关系
      *     c、根据namespaceUri从映射关系中找到对应的实现了NamespaceHandler接口的类
      *     d、调用类的init方法，init方法是注册了各种自定义标签的解析类
      *     e、根据namespaceUri找到对应的解析类，然后调用paser方法完成标签解析
      *
      * 3、把解析出来的xml标签封装成BeanDefinition对象
      * */
      // Tell the subclass to refresh the internal bean factory.
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

      /*
       * 给beanFactory设置一些属性值，可以不看
       * */
      // Prepare the bean factory for use in this context.
      prepareBeanFactory(beanFactory);

      // Allows post-processing of the bean factory in context subclasses.
      postProcessBeanFactory(beanFactory);

      /*
       * BeanDefinitionRegistryPostProcessor
       * BeanFactoryPostProcessor
       * 完成对这两个接口的调用
       * */
      // Invoke factory processors registered as beans in the context.
      invokeBeanFactoryPostProcessors(beanFactory);
   }
}
```

上一节讲了在XML配置下的BeanDefinition初始化和注册

```java
ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
```

这一节看

```
invokeBeanFactoryPostProcessors(beanFactory);
```

## invokeBeanFactoryPostProcessors

从方法的翻译----`调用Bean Factory后处理器`看，它是做一些后置处理的。

```java
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
  ....
}
```

> 这里的getBeanFactoryPostProcessors会返回一个List\<BeanFactoryPostProcessor>，这个集合是通过ApplicationContext的`addBeanFactoryPostProcessor`方法来添加值的

看invokeBeanFactoryPostProcessors：

```java
	public static void invokeBeanFactoryPostProcessors(
			ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {

		// Invoke BeanDefinitionRegistryPostProcessors first, if any.
		Set<String> processedBeans = new HashSet<>();

    // beanFactory是DefaultListableBeanFactory，它实现了BeanDefinitionRegistry接口
		if (beanFactory instanceof BeanDefinitionRegistry) {
			BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
			List<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();
			List<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();

      // 默认情况下beanFactoryPostProcessors会为空，可以通过addBeanFactoryPostProcessor方法来添加自己的BeanFactoryPostProcessor
			for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
				if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
					BeanDefinitionRegistryPostProcessor registryProcessor =
							(BeanDefinitionRegistryPostProcessor) postProcessor;
					registryProcessor.postProcessBeanDefinitionRegistry(registry);
					registryProcessors.add(registryProcessor);
				}
				else {
					regularPostProcessors.add(postProcessor);
				}
			}

			// Do not initialize FactoryBeans here: We need to leave all regular beans
			// uninitialized to let the bean factory post-processors apply to them!
			// Separate between BeanDefinitionRegistryPostProcessors that implement
			// PriorityOrdered, Ordered, and the rest.
			List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();

			//获取实现了BeanDefinitionRegistryPostProcessor接口的所有类的BeanDefinition对象的beanName
			// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
			String[] postProcessorNames =
					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
			for (String ppName : postProcessorNames) {
				if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
					processedBeans.add(ppName);
				}
			}
			//排序
			sortPostProcessors(currentRegistryProcessors, beanFactory);
			registryProcessors.addAll(currentRegistryProcessors);
			//调用过程
			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
			currentRegistryProcessors.clear();

			// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
			for (String ppName : postProcessorNames) {
				//判断是否是实现的Ordered接口
				if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
					processedBeans.add(ppName);
				}
			}
			sortPostProcessors(currentRegistryProcessors, beanFactory);
			registryProcessors.addAll(currentRegistryProcessors);
			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
			currentRegistryProcessors.clear();

			//没实现排序接口的调用
			// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
			boolean reiterate = true;
			while (reiterate) {
				reiterate = false;
				postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
				for (String ppName : postProcessorNames) {
					if (!processedBeans.contains(ppName)) {
						currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
						processedBeans.add(ppName);
						reiterate = true;
					}
				}
				sortPostProcessors(currentRegistryProcessors, beanFactory);
				registryProcessors.addAll(currentRegistryProcessors);
				invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
				currentRegistryProcessors.clear();
			}

			//调用postProcessBeanFactory方法
			// Now, invoke the postProcessBeanFactory callback of all processors handled so far.
			invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
			invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
		}

		else {
			// Invoke factory processors registered with the context instance.
			invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
		}

		// Do not initialize FactoryBeans here: We need to leave all regular beans
		// uninitialized to let the bean factory post-processors apply to them!
		String[] postProcessorNames =
				beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);

		// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
		// Ordered, and the rest.
		List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();
		List<String> orderedPostProcessorNames = new ArrayList<>();
		List<String> nonOrderedPostProcessorNames = new ArrayList<>();
		for (String ppName : postProcessorNames) {
			if (processedBeans.contains(ppName)) {
				// skip - already processed in first phase above
			}
			//实现了PriorityOrdered接口的
			else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
				priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
			}
			//实现了Ordered接口的
			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
				orderedPostProcessorNames.add(ppName);
			}
			else {
				//没实现接口的
				nonOrderedPostProcessorNames.add(ppName);
			}
		}

		//排序
		// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
		sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
		//调用
		invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);

		// Next, invoke the BeanFactoryPostProcessors that implement Ordered.
		List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());
		for (String postProcessorName : orderedPostProcessorNames) {
			orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
		}
		sortPostProcessors(orderedPostProcessors, beanFactory);
		invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);

		// Finally, invoke all other BeanFactoryPostProcessors.
		List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());
		for (String postProcessorName : nonOrderedPostProcessorNames) {
			nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
		}
		invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);

		// Clear cached merged bean definitions since the post-processors might have
		// modified the original metadata, e.g. replacing placeholders in values...
		beanFactory.clearMetadataCache();
	}
```

代码很长，不过跟着代码一步步走，beanFactory的实例类型是`DefaultListableBeanFactory`，而该类是实现了`BeanDefinitionRegistry`接口的，所以会进入第一个if。跟着代码一步步走，先看这段代码块

![image-20210313024832892](media/image-20210313024832892.png)

```java
String[] postProcessorNames =
					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
```

这代码的意思就是在之前注册的beanDefinition中，找到有实现了`BeanDefinitionRegistryPostProcessor`接口的beanDefinition，最后返回这些beanDefinition的beanName，看上图可以看到有名字返回。

> 请注意最后一个
> `org.springframework.context.annotation.internalConfigurationAnnotationProcessor`
> 这个对应的`beanDefinition`就是在扫描注解创建完beanDefinition并注册后，Spring自己加进来的RootBeanDefinition，该BeanDefinition指代的类为ConfigurationClassPostProcessor.class`
> 这里只是回忆下，现在还没涉及到这个class对象。

下面先介绍下`BeanDefinitionRegistryPostProcessor`接口的作用。

### `BeanDefinitionRegistryPostProcessor`的作用。

![image-20210313025629475](media/image-20210313025629475.png)

先看下定义：

![image-20210313025557942](media/image-20210313025557942.png)

![image-20210313025640669](media/image-20210313025640669.png)

> 从接口`BeanDefinitionRegistryPostProcessor`定义的抽象方法可以看到，带着注册中心，也就是说，这个接口的实现类完全可以获取到之前创建并注册完成的BeanDefinition！那我们可以做一些扩展，比如自己再注册个BeanDefinition或者修改下BeanDefinition也可以去实现扫描我们自定义的注解！也就是要增删改查BeanDefinition时可以实现这个接口！
>
> 而`BeanFactoryPostProcessor`的定义方法是需要传`BeanFactory`的，所以该方法更加适合做修改应用上下文，但由于该方法的入参会是DefaultListableBeanFactory，该类也实现了BeanDefinitionRegistry，所以这也能对BeanDefinition做增删改
>
> 使用场景：
>
> 1. 实现自己的自定义注解，并且注入到Spring容器中
>
> 这里定义了两个抽象方法，不过这两个方法的调用时机是不同的。从方法名可以了解一些信息
>
> - `postProcessBeanDefinitionRegistry`的重点是对BeanDefinition的处理
> - `postProcessBeanFactory`的重点是对BeanFactory对象属性的修改
>
> 参考类：
>
> ```java
> @Component
> public class BeanPro implements BeanDefinitionRegistryPostProcessor, PriorityOrdered, Ordered {
>     @Override
>     public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
>         //查询BeanDefinition
>         final String[] beanDefinitionNames = registry.getBeanDefinitionNames();
>         for (String beanDefinitionName : beanDefinitionNames) {
>             BeanDefinition beanDefinition = registry.getBeanDefinition(beanDefinitionName);
>             System.out.println(beanDefinition);
>         }
> 
>         GenericBeanDefinition genericBeanDefinition = new GenericBeanDefinition();
>         genericBeanDefinition.setBeanClass(BeanDefinitionBean.class);
>         MutablePropertyValues propertyValues = genericBeanDefinition.getPropertyValues();
>         propertyValues.add("name","Jack");
>         registry.registerBeanDefinition("beanDefinitionBean",genericBeanDefinition);
> 
> 
>         //也可以做自定义注解扫描
> //        ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(registry);
> //        //需要过滤的注解
> //        scanner.addIncludeFilter(new AnnotationTypeFilter(MyService.class));
> //        scanner.scan("com.enjoy.jack.customBean");
>     }
> 
>     @Override
>     public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
>         BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
>         String[] beanDefinitionNames = registry.getBeanDefinitionNames();
> 
>         DefaultListableBeanFactory beanFactory1 = (DefaultListableBeanFactory)beanFactory;
>         beanFactory1.setAllowBeanDefinitionOverriding(true);
>         beanFactory1.setAllowCircularReferences(true);
>         beanFactory1.setAllowRawInjectionDespiteWrapping(true);
>     }
> 
>    
>     @Override
>     public int getOrder() {
>         return 0;
>     }
> }
> 
> @Data
> public class BeanDefinitionBean {
>     private String name = "test";
> }
> ```



## 回到invokeBeanFactoryPostProcessors

![image-20210313024832892](media/image-20210313024832892.png)

```
String[] postProcessorNames =
					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
```

已经讲了，看for，for里面就是是判断下是否实现了PriorityOrdered这个排序接口，先看下我关注的类`ConfigurationClassPostProcessor`，看下该类的类图：

![image-20210313024104673](media/image-20210313024104673.png)

他有实现PriorityOrdered接口，所以会进入到方法

```
beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)
```

beanFactory的对象是`DefaultListableBeanFactory`，这个[getBean](./04-Spring的Bean实例化)方法会触发Spring Bean的初始化，作用就是是实例化`ConfigurationClassPostProcessor`对象，并完成控制反转（IOC）、依赖注入（DI）。更进一步说，就是实例化实现了BeanDefinitionRegistryPostProcessor接口和PriorityOrdered接口的类。

接着把实例化的对象放入到

```
List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();
```

这个集合中。最后把beanName放入

```
Set<String> processedBeans = new HashSet<>();
```

这个集合中。代码再往下走。

![image-20210313032536023](media/image-20210313032536023.png)

根据PriorityOrdered接口对currentRegistryProcessors集合排下序，接着把currentRegistryProcessors放到了这个集合中

```
List<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();
```

接着就是重点方法了，

```
invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
```

这个方法就是去对调用刚刚创建的实现了`BeanDefinitionRegistryPostProcessor`接口的对象的`postProcessBeanDefinitionRegistry`方法，这里只调用了一个方法，还有另一个方法`postProcessBeanFactory`会在之后被调用。

![image-20210313033052684](media/image-20210313033052684.png)

上面讲的是实现了`BeanDefinitionRegistryPostProcessor`接口和`PriorityOrdered`接口的，没实现的呢？继续看代码：

![image-20210313034007630](media/image-20210313034007630.png)

![image-20210313033747044](media/image-20210313033747044.png)

还是同样的味道，同样的套路。。。。。。。代码继续走

![image-20210313034159305](media/image-20210313034159305.png)

之前的都是调用了`BeanDefinitionRegistryPostProcessor`的`postProcessBeanBefinitionRegistry`方法，那最后就是调用`BeanDefinitionRegistryPostProcessor`的`postProcessBeanFactory`方法了。都是和上边同样的流程，

> 不过这里需要注意，最后的集合`regularPostProcessors`在默认的情况下是没有的，因为它需要手动调用ApplicationContext.addBeanFactoryPostProcessor方法才会有。

代码继续走，这次是获取实现了`BeanFactoryPostProcessor`接口的类了

![image-20210504041123086](media/image-20210504041123086.png)

之后的逻辑和排序都和上边的一样。



## 总结

这个方法方法很重要，甚至比前面第一节中，BeanFactory的创建还重要。因为在第一节中的讲的BeanDefinition的创建和注册是在`obtainFreshBeanFactory`完成的，这只是针对基于xml文件的，但现在随着注解的形式已经成为了主流，而基于注解的BeanDefinition的创建和注册不是在`obtainFreshBeanFactory`完成的，而是在这个方法中调用了ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry完成了BeanDefinition的创建和注册的。所以这个方法是一个非常非常重要的方法！！

看下默认排序的OrderComparator：

![image-20210504005907652](media/image-20210504005907652.png)

下面对这个方法中的BeanDefinitionRegistyPostProcess的调用顺序进行总结：

PriorityOrdered > Ordered > 非PriorityOrdered非Ordered

order越小越先被执行

还有一个AnnotationAwareOrderComparator.INSTANCE，这个排序是OrderComparator的子类，它支持@Priority、和@Order注解，排序规则还是和上边一样。

## 流程图

![BeanDefinitionRegistryPostProcessor和BeanFactoryPostProcessor](media/BeanDefinitionRegistryPostProcessor%E5%92%8CBeanFactoryPostProcessor.jpg)

