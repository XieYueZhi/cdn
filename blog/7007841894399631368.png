# Spring缓存切面

缓存切面在有了AOP和事务的知识后就觉得很简单了。

先说使用。加上这个注解`@EnableCaching`，还是老套路，看注解的定义

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(CachingConfigurationSelector.class)
public @interface EnableCaching {

	boolean proxyTargetClass() default false;

	AdviceMode mode() default AdviceMode.PROXY;

	int order() default Ordered.LOWEST_PRECEDENCE;

}
```

这个注解就是为了引入`CachingConfigurationSelector.class`这个启动类。老套路了，我就不细说了，注解看核心代码。

```java
private String[] getProxyImports() {
	List<String> result = new ArrayList<>(3);
	result.add(AutoProxyRegistrar.class.getName());
	result.add(ProxyCachingConfiguration.class.getName());
	if (jsr107Present && jcacheImplPresent) {
		result.add(PROXY_JCACHE_CONFIGURATION_CLASS);
	}
	return StringUtils.toStringArray(result);
}
```

还是一样的套路啊，通过AutoProxyRegistrar.class加上生成代理功能。ProxyCachingConfiguration.class这个不看都知道就是为了创建切面的。

```java
@Configuration
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
public class ProxyCachingConfiguration extends AbstractCachingConfiguration {

	@Bean(name = CacheManagementConfigUtils.CACHE_ADVISOR_BEAN_NAME)
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	public BeanFactoryCacheOperationSourceAdvisor cacheAdvisor() {
		BeanFactoryCacheOperationSourceAdvisor advisor = new BeanFactoryCacheOperationSourceAdvisor();
		advisor.setCacheOperationSource(cacheOperationSource());
		advisor.setAdvice(cacheInterceptor());
		if (this.enableCaching != null) {
			advisor.setOrder(this.enableCaching.<Integer>getNumber("order"));
		}
		return advisor;
	}

	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	public CacheOperationSource cacheOperationSource() {
		return new AnnotationCacheOperationSource();
	}

	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	public CacheInterceptor cacheInterceptor() {
		CacheInterceptor interceptor = new CacheInterceptor();
		interceptor.configure(this.errorHandler, this.keyGenerator, this.cacheResolver, this.cacheManager);
		interceptor.setCacheOperationSource(cacheOperationSource());
		return interceptor;
	}

}
```

切面是`BeanFactoryCacheOperationSourceAdvisor`，pointcut是`CacheOperationSourcePointcut`，Advice是`CacheInterceptor`，通知切面和Advice中包含`AnnotationCacheOperationSource`。这是真的和事务很像啊。功事务切面的经验猜测`AnnotationCacheOperationSource`的作用就是解析缓存注解的。



## `CacheOperationSourcePointcut`

```java
@Override
public boolean matches(Method method, Class<?> targetClass) {
	CacheOperationSource cas = getCacheOperationSource();
	return (cas != null && !CollectionUtils.isEmpty(cas.getCacheOperations(method, targetClass)));
}
```

老实说，这个和事务是一个套路，我在这重点说下解析那部分，代码

```
AbstractFallbackCacheOperationSource#getCacheOperations -->
AbstractFallbackCacheOperationSource#computeCacheOperations -->
AnnotationCacheOperationSource#findCacheOperations
```

```java
protected Collection<CacheOperation> findCacheOperations(Method method) {
	return determineCacheOperations(parser -> parser.parseCacheAnnotations(method));
}
```

```java
@Nullable
protected Collection<CacheOperation> determineCacheOperations(CacheOperationProvider provider) {
	Collection<CacheOperation> ops = null;
	for (CacheAnnotationParser parser : this.annotationParsers) {
		Collection<CacheOperation> annOps = provider.getCacheOperations(parser);
		if (annOps != null) {
			if (ops == null) {
				ops = annOps;
			}
			else {
				Collection<CacheOperation> combined = new ArrayList<>(ops.size() + annOps.size());
				combined.addAll(ops);
				combined.addAll(annOps);
				ops = combined;
			}
		}
	}
	return ops;
}
```

`this.annotationParsers`是在构造函数中传入的。

![image-20210322015543273](media/image-20210322015543273.png)

provider的入参是parser -> parser.parseCacheAnnotations(method)，所以看

`SpringCacheAnnotationParser#parseCacheAnnotations`，跟踪代码到

![image-20210322015759911](media/image-20210322015759911.png)

![image-20210322015808916](media/image-20210322015808916.png)

这里会把不同的注解解析成不同的对象，下面汇总下对应关系：

- Cacheable——CacheableOperation

- CacheEvict——CacheEvictOperation

- CachePut——CachePutOperation

  

## CacheInterceptor

```java
public Object invoke(final MethodInvocation invocation) throws Throwable {
	Method method = invocation.getMethod();

	CacheOperationInvoker aopAllianceInvoker = () -> {
		try {
			return invocation.proceed();
		}
		catch (Throwable ex) {
			throw new CacheOperationInvoker.ThrowableWrapper(ex);
		}
	};

	try {
		return execute(aopAllianceInvoker, invocation.getThis(), method, invocation.getArguments());
	}
	catch (CacheOperationInvoker.ThrowableWrapper th) {
		throw th.getOriginal();
	}
}
```

这里先记下CacheOperationInvoker的作用就是进行火炬传递的。

```java
protected Object execute(CacheOperationInvoker invoker, Object target, Method method, Object[] args) {
	// Check whether aspect is enabled (to cope with cases where the AJ is pulled in automatically)
	if (this.initialized) {
		Class<?> targetClass = getTargetClass(target);
		CacheOperationSource cacheOperationSource = getCacheOperationSource();
		if (cacheOperationSource != null) {
			Collection<CacheOperation> operations = cacheOperationSource.getCacheOperations(method, targetClass);
			if (!CollectionUtils.isEmpty(operations)) {
				return execute(invoker, method,
						new CacheOperationContexts(operations, method, args, target, targetClass));
			}
		}
	}

	return invoker.invoke();
}
```

execute的入参是CacheOperationInvoker，被代理对象，执行的方法，方法参数

initialized这个参数在`afterSingletonsInstantiated`后就变成true了。

![image-20210322021019078](media/image-20210322021019078.png)

这行的作用就是通过方法和class对象生成一个MethodClassKey对象，然后用这个对象从缓存中获取到之前解析得到对象。

![image-20210322021050124](media/image-20210322021050124.png)

![image-20210322021258479](media/image-20210322021258479.png)

接着在执行下一个execute方法前会把必须信息包装成`CacheOperationContexts`对象。看第二个execute方法

```java
private Object execute(final CacheOperationInvoker invoker, Method method, CacheOperationContexts contexts) {
  //非关键代码  
  .....  

	//先处理@CacheEvicts的逻辑,,其实就是掉clear方法
	// Process any early evictions
	processCacheEvicts(contexts.get(CacheEvictOperation.class), true,
			CacheOperationExpressionEvaluator.NO_RESULT);

	//处理@Cacheable的逻辑,,其实就是掉get方法
	// Check if we have a cached item matching the conditions
	Cache.ValueWrapper cacheHit = findCachedItem(contexts.get(CacheableOperation.class));

	// Collect puts from any @Cacheable miss, if no cached item is found
	List<CachePutRequest> cachePutRequests = new LinkedList<>();
	//如果缓存没命中或者不是使用的@Cacheable注解
	if (cacheHit == null) {
		//处理@Cacheable的逻辑，收集插入请求,插入缓存的值需要调用被代理方法
		collectPutRequests(contexts.get(CacheableOperation.class),
				CacheOperationExpressionEvaluator.NO_RESULT, cachePutRequests);
	}

	Object cacheValue;
	Object returnValue;

	//如果缓存命中了
	if (cacheHit != null && !hasCachePut(contexts)) {
		// If there are no put requests, just use the cache hit
		cacheValue = cacheHit.get();
		//直接返回缓存中的值
		returnValue = wrapCacheValue(method, cacheValue);
	}
	else {
		//在这里调用被代理方法
		// Invoke the method if we don't have a cache hit
		returnValue = invokeOperation(invoker);
		cacheValue = unwrapReturnValue(returnValue);
	}

	//处理@CachePut注解,收集put请求
	// Collect any explicit @CachePuts
	collectPutRequests(contexts.get(CachePutOperation.class), cacheValue, cachePutRequests);

	//处理put请求，其实就是掉put方法
	// Process any collected put requests, either from @CachePut or a @Cacheable miss
	for (CachePutRequest cachePutRequest : cachePutRequests) {
		cachePutRequest.apply(cacheValue);
	}

	// Process any late evictions
	processCacheEvicts(contexts.get(CacheEvictOperation.class), false, cacheValue);

	return returnValue;
}
```

我们重点看Cacheable注解的。

![image-20210322023504500](media/image-20210322023504500.png)

获取方法方法上的Cacheable对应的操作类CacheableOperation。

```java
private Cache.ValueWrapper findCachedItem(Collection<CacheOperationContext> contexts) {
	Object result = CacheOperationExpressionEvaluator.NO_RESULT;
	for (CacheOperationContext context : contexts) {
		if (isConditionPassing(context, result)) {
			Object key = generateKey(context, result);
			Cache.ValueWrapper cached = findInCaches(context, key);
			if (cached != null) {
				return cached;
			}
			else {
        。。。
			}
		}
	}
	return null;
}

private Cache.ValueWrapper findInCaches(CacheOperationContext context, Object key) {
	for (Cache cache : context.getCaches()) {
		Cache.ValueWrapper wrapper = doGet(cache, key);
		if (wrapper != null) {
			。。。
			return wrapper;
		}
	}
	return null;
}

protected Cache.ValueWrapper doGet(Cache cache, Object key) {
	try {
		return cache.get(key);
	}
	catch (RuntimeException ex) {
		getErrorHandler().handleCacheGetError(ex, cache, key);
		return null;  // If the exception is handled, return a cache miss
	}
}
```

然后从Cache对象中遍历获取，找到就返回。如果缓存没命中呢？流程代码接着走，

![image-20210322032115649](media/image-20210322032115649.png)

如果缓存没命中，这时就需要执行业务代码，获取值了，而Spring是先收集下@Cacheable的需要设置值的缓存，并生成对应的CachePutRequest对象。接着会就执行这段代码

![image-20210322032504215](media/image-20210322032504215.png)

![image-20210322032511503](media/image-20210322032511503.png)

这个invokeOperation()就是进行火炬传递，执行目标方法的，有值了，Spring这时还没有去往缓存中放值，而是好要收集下@CachePut的CachePutRequest。

![image-20210322032624953](media/image-20210322032624953.png)

最后

![image-20210322032839021](media/image-20210322032839021.png)

这了就是真正的往缓存中设置值的代码了。apply方法只是调用了Cache.put方法而已。



